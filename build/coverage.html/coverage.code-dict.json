{"/home/travis/build/npmtest/node-npmtest-seneca/test.js":"/* istanbul instrument in package npmtest_seneca */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-seneca/lib.npmtest_seneca.js":"/* istanbul instrument in package npmtest_seneca */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_seneca = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_seneca = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-seneca/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-seneca && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_seneca */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_seneca\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_seneca.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_seneca.rollup.js'] =\n            local.assetsDict['/assets.npmtest_seneca.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_seneca.__dirname +\n                    '/lib.npmtest_seneca.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/seneca.js":"/* Copyright (c) 2010-2016 Richard Rodger and other contributors, MIT License */\n'use strict'\n\n\n// Node API modules.\nvar Assert = require('assert')\nvar Events = require('events')\nvar Util = require('util')\n\n\n// External modules.\nvar _ = require('lodash')\nvar Eraro = require('eraro')\nvar GateExecutor = require('gate-executor')\nvar Jsonic = require('jsonic')\nvar Makeuse = require('use-plugin')\nvar Nid = require('nid')\nvar Norma = require('norma')\nvar Patrun = require('patrun')\nvar Stats = require('rolling-stats')\nvar Ordu = require('ordu')\nvar Lrucache = require('lru-cache')\n\n\n// Internal modules.\nvar Actions = require('./lib/actions')\nvar Common = require('./lib/common')\nvar Errors = require('./lib/errors')\nvar Legacy = require('./lib/legacy')\nvar Optioner = require('./lib/optioner')\nvar Package = require('./package.json')\nvar Plugins = require('./lib/plugins')\nvar Print = require('./lib/print')\nvar Transport = require('./lib/transport')\n\n\n// Shortcuts\nvar errlog = Common.make_standard_err_log_entry\nvar actlog = Common.make_standard_act_log_entry\n\n\n// Internal data and utilities\nvar error = Eraro({\n  package: 'seneca',\n  msgmap: Errors,\n  override: true\n})\n\nvar option_defaults = {\n  // Tag this Seneca instance, will be appended to instance identifier.\n  tag: '-',\n\n  // Standard timeout for actions.\n  timeout: 22222,\n\n  // Standard length of identifiers for actions.\n  idlen: 12,\n\n  // Register (true) default plugins. Set false to not register when\n  // using custom versions.\n  default_plugins: {\n    transport: true\n  },\n\n  // Test mode. Use for unit testing.\n  test: false,\n\n  // Wait time for plugins to close gracefully.\n  deathdelay: 11111,\n\n  // Debug settings.\n  debug: {\n    // Throw (some) errors from seneca.act.\n    fragile: false,\n\n    // Fatal errors ... aren't fatal. Not for production!\n    undead: false,\n\n    // Print debug info to console\n    print: {\n      // Print options. Best used via --seneca.print.options.\n      options: false\n    },\n\n    // Trace action caller and place in args.caller$.\n    act_caller: false,\n\n    // Shorten all identifiers to 2 characters.\n    short_logs: false,\n\n    // Record and log callpoints (calling code locations).\n    callpoint: false,\n\n    // Log deprecation warnings\n    deprecation: true\n  },\n\n  // Enforce strict behaviours. Relax when backwards compatibility needed.\n  strict: {\n    // Action result must be a plain object.\n    result: true,\n\n    // Delegate fixedargs override action args.\n    fixedargs: true,\n\n    // Adding a pattern overrides existing pattern only if matches exactly.\n    add: false,\n\n    // If no action is found and find is false,\n    // then no error returned along with empty object\n    find: true,\n\n    // Maximum number of times an action can call itself\n    maxloop: 11\n  },\n\n  // Action cache. Makes inbound messages idempotent.\n  actcache: {\n    active: false,\n    size: 11111\n  },\n\n  // Action executor tracing. See gate-executor module.\n  trace: {\n    act: false,\n    stack: false,\n\n    // Messages that do not match a known pattern\n    unknown: true,\n\n    // Messages that have invalid content\n    invalid: false\n  },\n\n  // Action statistics settings. See rolling-stats module.\n  stats: {\n    size: 1024,\n    interval: 60000,\n    running: false\n  },\n\n  // Plugin settings\n  plugin: {},\n\n  // System wide functionality.\n  system: {\n    // seneca.add uses catchall (pattern='') prior\n    catchall: false,\n\n    // Close instance on these signals, if true.\n    close_signals: {\n      SIGHUP: true,\n      SIGTERM: true,\n      SIGINT: true,\n      SIGBREAK: true\n    }\n  },\n\n  // Internal functionality. Reserved for objects and functions only.\n  internal: {},\n\n  // Log status at periodic intervals.\n  status: {\n    interval: 60000,\n\n    // By default, does not run.\n    running: false\n  },\n\n  // Backwards compatibility settings.\n  legacy: {\n\n    // Action callback must always have signature callback(error, result).\n    action_signature: false,\n\n    // Logger can be changed by options method.\n    logging: false,\n\n    // Use old error codes.\n    error_codes: false\n  }\n}\n\n\n// Utility functions exposed by Seneca via `seneca.util`.\nvar seneca_util = {\n  deepextend: Common.deepextend,\n  recurse: Common.recurse,\n  clean: Common.clean,\n  copydata: Common.copydata,\n  nil: Common.nil,\n  parsepattern: Common.parsePattern,\n  pattern: Common.pattern,\n  print: Common.print,\n  pincanon: Common.pincanon,\n  router: function router () { return Patrun() },\n  argprops: Common.argprops\n}\n\n\n// Seneca is an EventEmitter.\nfunction Seneca () {\n  Events.EventEmitter.call(this)\n  this.setMaxListeners(0)\n}\nUtil.inherits(Seneca, Events.EventEmitter)\n\n\n// Create a Seneca instance.\nmodule.exports = function init (seneca_options, more_options) {\n  var initial_options = _.isString(seneca_options)\n        ? _.extend({}, {from: seneca_options}, more_options)\n      : _.extend({}, seneca_options, more_options)\n\n  var seneca = make_seneca(initial_options)\n  var options = seneca.options()\n\n  // The 'internal' key of options is reserved for objects and functions\n  // that provide functionality, and are thus not really printable\n  seneca.log.debug({kind: 'notice', options: _.omit(options, ['internal'])})\n\n  Print.print_options(options)\n\n  // TODO: these are core API and should not be decorations\n  seneca.decorate('hasplugin', Plugins.api_decorations.hasplugin)\n  seneca.decorate('findplugin', Plugins.api_decorations.findplugin)\n  seneca.decorate('plugins', Plugins.api_decorations.plugins)\n\n  // Register default plugins, unless turned off by options.\n  if (options.default_plugins.transport) {\n    seneca.use(require('seneca-transport'))\n  }\n\n  // Register plugins specified in options.\n  _.each(options.plugins, function (plugindesc) {\n    seneca.use(plugindesc)\n  })\n\n  seneca.ready(function () {\n    this.log.info({kind: 'notice', notice: 'hello seneca ' + seneca.id})\n  })\n\n  return seneca\n}\n\n// Expose Seneca prototype for easier monkey-patching\nmodule.exports.Seneca = Seneca\n\n// To reference builtin loggers when defining logging options.\nmodule.exports.loghandler = Legacy.loghandler\n\n// Makes require('seneca').use(...) work by creating an on-the-fly instance.\nmodule.exports.use = function top_use () {\n  var argsarr = new Array(arguments.length)\n  for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n  var instance = module.exports()\n\n  return instance.use.apply(instance, argsarr)\n}\n\n// Makes require('seneca').test() work.\nmodule.exports.test = function top_test () {\n  var argsarr = new Array(arguments.length)\n  for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n  var instance = module.exports({test: true, log: 'test'})\n  instance.test.apply(instance, argsarr)\n\n  return instance\n}\n\nmodule.exports.util = seneca_util\n\n\n// Mostly for testing.\nif (require.main === module) {\n  module.exports()\n}\n\n// Create a new Seneca instance.\n// * _initial_options_ `o` &rarr; instance options\nfunction make_seneca (initial_options) {\n  initial_options = initial_options || {}\n\n  // Create a private context.\n  var private$ = make_private()\n\n  // Create a new root Seneca instance.\n  var root = new Seneca()\n  root.make_log = make_log\n\n  // Expose private data to plugins.\n  root.private$ = private$\n\n  // Resolve initial options.\n  private$.optioner = Optioner(module, option_defaults, initial_options)\n  var so = private$.optioner.get()\n\n  // Create internal tools.\n  var actnid = Nid({length: so.idlen})\n  var refnid = function refnid () { return '(' + actnid() + ')' }\n\n  // These need to come from options as required during construction.\n  so.internal.actrouter = so.internal.actrouter || Patrun({ gex: true })\n  so.internal.subrouter = so.internal.subrouter || Patrun({ gex: true })\n\n  var callpoint = make_callpoint(so.debug.callpoint)\n\n  // Define public member variables.\n  root.root = root\n  root.start_time = Date.now()\n  root.fixedargs = {}\n  root.context = {}\n  root.version = Package.version\n\n  private$.actcache = Lrucache({ max: so.actcache.size })\n\n\n  // Seneca methods. Official API.\n\n  // <a name=\"seneca.add\">**seneca.add**</a>\n  //\n  // Add a message pattern and action.\n  //   * `pattern` <small>_string|object_</small> &rarr;\n  //   Pattern definition as\n  //   [jsonic](https://github.com/rjrodger/jsonic) string or object.\n  //\n  //   * `action` <small>_function (optional)_</small> &rarr;\n  //   Action function.\n  //\n  // When a message that matches the pattern is submitted inward using\n  // `seneca.act`, the action function is called with parameters:\n  //   * `message` <small>_object_</small> &rarr; Message object.\n  //   * `reply` <small>_function_</small> &rarr; Callback function.\n  //\n  // The `reply` callback is used to provide a response to the\n  // message.  If the action function is not provided, the pattern\n  // will be added with a default action function that does\n  // nothing. The `reply` callback has parameters:\n  //   * `error` <small>_Error (optional)_</small> &rarr;\n  //   Provide this value if you wish to provide an error response to the message.\n  //   * `response` <small>_object|array (optional)_</small> &rarr;\n  //   Response data to the message.\n  //\n  // **The action function is not a lambda, and the `=>` function\n  // syntax should not be used.** The context `this` of the action\n  // function is a reference to the current Seneca instance, tha\n  // should always be used for subsequent `seneca.act` calls, as this\n  // enables accurate tracing of actions.\n  //\n  // If the pattern added has been added previously, then the new\n  // action function overrides the old action function. The old action\n  // function is available via the `seneca.prior` method of the\n  // current Seneca instance (`this` in the new action function).  A\n  // chain of priors is formed if additional action functions with the\n  // same pattern are added. There is a tutorial on [Seneca\n  // priors](http://senecajs.org/tutorials/priors.html).\n  root.add = api_add\n\n  // # Seneca.act\n  //\n  // Send a message. If the message matches a pattern, execute the\n  // action function.\n  //   * `msg` <small>_object_</small> &rarr;\n  //   The message data. Only data that can be fully represented as JSON is valid.\n  //   * `callback` <small>_function (optional)_</small> &rarr;\n  //   The callback function that will receive the response to the\n  //   message, generated by the action function.\n  //\n  // The message data may contain control properties, indicated by a\n  // `$` suffix.  These are described in the [control properties\n  // reference](http://senecajs.org/documentation/control-properties.html)\n  //\n  // **The callback function should not be a lambda (`=>`)**. The current\n  // Seneca instance is provided via `this`, and should be used for\n  // subsequent `seneca.act` calls, as this enables accurate tracing\n  // of actions.\n  //\n  // If the callback function is provided, then the message\n  // interaction is assumed to be synchronous, and a response from the\n  // action function will be expected. If the callback function is not\n  // provided, the interaction is assumed to be asynchronous, and no\n  // response is expected.\n  //\n  // The callback function has parameters:\n  //   * `error` <small>_Error_</small> &rarr; If an error occurred,\n  //   an Error object will be provided, otherwise this is `null`. If\n  //   the action times out, an error will be provided.\n  //   * `response` <small>_object|array_</small> &rarr;\n  //   The response data from the action function, if any.\n  //\n  // For convenience, you can build the full message from separate\n  // parts, including [jsonic](https://github.com/rjrodger/jsonic)\n  // strings. The full set of parameters to `seneca.act` is:\n  //   * `jsonic` <small>_string (optional)_</small> &rarr;\n  //   Message properties in jsonic format. These have precedence over\n  //   other message parts.\n  //   * `part1` <small>_object (optional)_</small> &rarr;\n  //   Message data having precedence over `part2`.\n  //   * `part2` <small>_object (optional)_</small> &rarr;\n  //   Message data.\n  //   * `callback` <small>_function (optional)_</small> &rarr;\n  //   As previously described.\n  root.act = api_act // Perform action that matches pattern.\n\n  root.sub = api_sub // Subscribe to a message pattern.\n  root.use = api_use // Define a plugin.\n  root.listen = Transport.listen(callpoint) // Listen for inbound messages.\n  root.client = Transport.client(callpoint) // Send outbound messages.\n  root.export = api_export // Export plain objects from a plugin.\n  root.has = Actions.has // True if action pattern defined.\n  root.find = Actions.find // Find action by pattern\n  root.list = Actions.list // List (a subset of) action patterns.\n  root.ready = api_ready // Callback when plugins initialized.\n  root.close = api_close // Close and shutdown plugins.\n  root.options = api_options // Get and set options.\n  root.error = api_error // Set global error handler.\n  root.decorate = api_decorate // Decorate seneca object with functions\n  root.inward = api_inward // Add a modifier function for messages inward\n  root.outward = api_outward // Add a modifier function for responses outward\n  root.test = api_test // Set test mode.\n\n  // Method aliases.\n  root.hasact = root.has\n\n  // Non-API methods.\n  root.register = Plugins.register(so, callpoint)\n  root.depends = api_depends\n  root.act_if = api_act_if\n  root.wrap = api_wrap\n  root.seneca = api_seneca\n  root.fix = api_fix\n  root.delegate = api_delegate\n\n  // Legacy API; Deprecated.\n  root.findact = root.find\n\n  // DEPRECATED\n  root.fail = Legacy.fail(so)\n\n  // Identifier generator.\n  root.idgen = Nid({length: so.idlen})\n  so.tag = so.tag || option_defaults.tag\n  so.tag = so.tag === 'undefined' ? option_defaults.tag : so.tag\n\n  // Create a unique identifer for this instance.\n  root.id = root.idgen() +\n    '/' +\n    root.start_time +\n    '/' +\n    process.pid +\n    '/' +\n    root.version +\n    '/' +\n    so.tag\n\n  // The instance tag, useful for grouping instances.\n  root.tag = so.tag\n\n  if (so.debug.short_logs || so.log.short) {\n    so.idlen = 2\n    root.idgen = Nid({length: so.idlen})\n    root.id = root.idgen() + '/' + so.tag\n  }\n\n  root.fullname = 'Seneca/' + root.id\n\n  root.die = Common.makedie(root, {\n    type: 'sys',\n    plugin: 'seneca',\n    tag: root.version,\n    id: root.id,\n    callpoint: callpoint\n  })\n\n  root.util = seneca_util\n\n\n  // Configure logging\n  private$.exports = { options: Common.deepextend({}, so) }\n  private$.decorations = {}\n\n  private$.logger = load_logger(root, so.internal.logger)\n  root.log = make_log(root, default_log_modifier)\n\n\n  // Error events are fatal, unless you're undead.  These are not the\n  // same as action errors, these are unexpected internal issues.\n  root.on('error', root.die)\n\n  private$.ge =\n    GateExecutor({\n      timeout: so.timeout\n    })\n    .clear(action_queue_clear)\n    .start()\n\n  // setup status log\n  if (so.status.interval > 0 && so.status.running) {\n    private$.stats = private$.stats || {}\n    setInterval(function status () {\n      root.log.info({\n        kind: 'status',\n        alive: (Date.now() - private$.stats.start),\n        act: private$.stats.act\n      })\n    }, so.status.interval)\n  }\n\n  if (so.stats) {\n    private$.timestats = new Stats.NamedStats(so.stats.size, so.stats.interval)\n\n    if (so.stats.running) {\n      setInterval(function stats () {\n        private$.timestats.calculate()\n      }, so.stats.interval)\n    }\n  }\n\n  private$.plugins = {}\n  private$.plugin_order = { byname: [], byref: [] }\n  private$.use = Makeuse({\n    prefix: 'seneca-',\n    module: module,\n    msgprefix: false,\n    builtin: ''\n  })\n\n  private$.actrouter = so.internal.actrouter\n  private$.subrouter = so.internal.subrouter\n\n  root.toString = api_toString\n\n  private$.action_modifiers = []\n  private$.ready_list = []\n\n\n  private$.inward = Ordu({name: 'inward'})\n    .add(Actions.inward.closed)\n    .add(Actions.inward.resolve_msg_id)\n    .add(Actions.inward.act_cache)\n    .add(Actions.inward.act_default)\n    .add(Actions.inward.act_not_found)\n    .add(Actions.inward.act_stats)\n    .add(Actions.inward.validate_msg)\n    .add(Actions.inward.warnings)\n    .add({tags: ['prior']}, Actions.inward.msg_meta)\n    .add({tags: ['xprior']}, Actions.inward.prepare_delegate)\n    .add(Actions.inward.msg_modify)\n    .add(Actions.inward.announce)\n\n  private$.outward = Ordu({name: 'outward'})\n    .add(Actions.outward.act_stats)\n    .add(Actions.outward.act_cache)\n    .add(Actions.outward.res_object)\n\n\n  function api_depends () {\n    var self = this\n\n    var args = Norma('{pluginname:s deps:a? moredeps:s*}', arguments)\n\n    var deps = args.deps || args.moredeps\n\n    _.every(deps, function (depname) {\n      if (!_.includes(private$.plugin_order.byname, depname) &&\n        !_.includes(private$.plugin_order.byname, 'seneca-' + depname)) {\n        self.die(error('plugin_required', { name: args.pluginname, dependency: depname }))\n        return false\n      }\n      else return true\n    })\n  }\n\n  function api_export (key) {\n    var self = this\n\n    // Legacy aliases\n    if (key === 'util') {\n      key = 'basic'\n    }\n\n    var exportval = private$.exports[key]\n    if (!exportval) {\n      return self.die(error('export_not_found', {key: key}))\n    }\n\n    return exportval\n  }\n\n  function api_sub () {\n    var self = this\n\n    var subargs = Common.parsePattern(self, arguments, 'action:f actmeta:o?')\n    var pattern = subargs.pattern\n    if (pattern.in$ == null &&\n      pattern.out$ == null &&\n      pattern.error$ == null &&\n      pattern.cache$ == null &&\n      pattern.default$ == null &&\n      pattern.client$ == null) {\n      pattern.in$ = true\n    }\n\n    if (!private$.handle_sub) {\n      private$.handle_sub = function handle_sub (args, result) {\n        args.meta$ = args.meta$ || {}\n\n        if (!args.meta$.prior || !args.meta$.prior.entry) {\n          return\n        }\n\n        var subfuncs = private$.subrouter.find(args)\n\n        if (subfuncs) {\n          args.meta$.sub = subfuncs.pattern\n\n          _.each(subfuncs, function subfunc (subfunc) {\n            try {\n              subfunc.call(self, args, result)\n            }\n            catch (ex) {\n              // TODO: not really satisfactory\n              var err = error(ex, 'sub_function_catch', { args: args, result: result })\n              self.log.error(errlog(err, {\n                kind: 'sub',\n                msg: args,\n                actid: args.meta$.id\n              }))\n            }\n          })\n        }\n      }\n\n      // TODO: other cases\n\n      // Subs are triggered via events\n      self.on('act-in', annotate('in$', private$.handle_sub))\n      self.on('act-out', annotate('out$', private$.handle_sub))\n    }\n\n    function annotate (prop, handle_sub) {\n      return function annotation (args, result) {\n        args = _.clone(args)\n        result = _.clone(result)\n        args[prop] = true\n        handle_sub(args, result)\n      }\n    }\n\n    var subs = private$.subrouter.find(pattern)\n    if (!subs) {\n      private$.subrouter.add(pattern, subs = [])\n      subs.pattern = Common.pattern(pattern)\n    }\n    subs.push(subargs.action)\n\n    return self\n  }\n\n\n  // See [`seneca.add`](#seneca.add)\n  function api_add () {\n    var self = this\n    var args = Common.parsePattern(self, arguments, 'action:f? actmeta:o?')\n\n    var raw_pattern = args.pattern\n\n    var pattern = self.util.clean(raw_pattern)\n\n    if (!_.keys(pattern)) {\n      throw error('add_empty_pattern', {args: Common.clean(args)})\n    }\n\n\n    var action = args.action || function default_action (msg, done) {\n      done.call(this, null, msg.default$ || null)\n    }\n\n    var actmeta = args.actmeta || {}\n\n    actmeta.raw = _.cloneDeep(raw_pattern)\n\n    // TODO: refactor plugin name, tag and fullname handling.\n    actmeta.plugin_name = actmeta.plugin_name || 'root$'\n    actmeta.plugin_fullname = actmeta.plugin_fullname ||\n      actmeta.plugin_name +\n      ((actmeta.plugin_tag === '-' ? void 0 : actmeta.plugin_tag)\n       ? '/' + actmeta.plugin_tag : '')\n\n    var add_callpoint = callpoint()\n    if (add_callpoint) {\n      actmeta.callpoint = add_callpoint\n    }\n\n    actmeta.sub = !!raw_pattern.sub$\n    actmeta.client = !!raw_pattern.client$\n\n    // Deprecate a pattern by providing a string message using deprecate$ key.\n    actmeta.deprecate = raw_pattern.deprecate$\n\n    var strict_add = (raw_pattern.strict$ && raw_pattern.strict$.add !== null)\n      ? !!raw_pattern.strict$.add : !!so.strict.add\n\n    var internal_catchall = (raw_pattern.internal$ && raw_pattern.internal$.catchall !== null)\n      ? !!raw_pattern.internal$.catchall : !!so.internal.catchall\n\n    var pattern_rules = _.clone(action.validate || {})\n    _.each(pattern, function (v, k) {\n      if (_.isObject(v)) {\n        pattern_rules[k] = _.clone(v)\n        delete pattern[k]\n      }\n    })\n\n    var addroute = true\n\n    // TODO: deprecate\n    actmeta.args = _.clone(pattern)\n\n    actmeta.rules = pattern_rules\n\n    actmeta.id = refnid()\n    actmeta.func = action\n\n    // Canonical string form of the action pattern.\n    actmeta.pattern = Common.pattern(pattern)\n\n    // Canonical object form of the action pattern.\n    actmeta.msgcanon = Jsonic(actmeta.pattern)\n\n\n    var priormeta = self.find(pattern)\n\n    if (priormeta) {\n      if (!internal_catchall && '' === priormeta.pattern) {\n        priormeta = null\n      }\n\n      // only exact action patterns are overridden\n      // use .wrap for pin-based patterns\n      else if (strict_add && priormeta.pattern !== actmeta.pattern) {\n        priormeta = null\n      }\n    }\n\n    if (priormeta) {\n      if (_.isFunction(priormeta.handle)) {\n        priormeta.handle(args.pattern, action)\n        addroute = false\n      }\n      else {\n        actmeta.priormeta = priormeta\n      }\n      actmeta.priorpath = priormeta.id + ';' + priormeta.priorpath\n    }\n    else {\n      actmeta.priorpath = ''\n    }\n\n    // FIX: need a much better way to support layered actions\n    // this \".handle\" hack is just to make seneca.close work\n    if (action && actmeta && _.isFunction(action.handle)) {\n      actmeta.handle = action.handle\n    }\n\n    private$.stats.actmap[actmeta.pattern] =\n      private$.stats.actmap[actmeta.pattern] || make_action_stats(actmeta)\n\n    actmeta = modify_action(self, actmeta)\n\n    if (addroute) {\n      self.log.debug({\n        kind: 'add',\n        case: actmeta.sub ? 'SUB' : 'ADD',\n        id: actmeta.id,\n        pattern: actmeta.pattern,\n        name: action.name,\n        callpoint: callpoint\n      })\n\n      private$.actrouter.add(pattern, actmeta)\n    }\n\n    return self\n  }\n\n\n  function make_action_stats (actmeta) {\n    return {\n      id: actmeta.id,\n      plugin: {\n        full: actmeta.plugin_fullname,\n        name: actmeta.plugin_name,\n        tag: actmeta.plugin_tag\n      },\n      prior: actmeta.priorpath,\n      calls: 0,\n      done: 0,\n      fails: 0,\n      time: {}\n    }\n  }\n\n\n  function modify_action (seneca, actmeta) {\n    _.each(private$.action_modifiers, function (actmod) {\n      actmeta = actmod.call(seneca, actmeta)\n    })\n\n    return actmeta\n  }\n\n\n  // TODO: deprecate\n  root.findpins = root.pinact = function findpins () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var pins = []\n    var patterns = _.flatten(argsarr)\n\n    _.each(patterns, function (pattern) {\n      pattern = _.isString(pattern) ? Jsonic(pattern) : pattern\n      pins = pins.concat(_.map(private$.actrouter.list(pattern),\n        function (desc) {\n          return desc.match\n        }\n      ))\n    })\n\n    return pins\n  }\n\n\n  // DEPRECATED\n  function api_act_if () {\n    var self = this\n    var args = Norma('{execute:b actargs:.*}', arguments)\n\n    if (args.execute) {\n      return self.act.apply(self, args.actargs)\n    }\n    else return self\n  }\n\n\n  // Perform an action. The properties of the first argument are matched against\n  // known patterns, and the most specific one wins.\n  function api_act () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var self = this\n    var spec = Common.parsePattern(self, argsarr, 'done:f?')\n    var msg = _.extend(spec.pattern, self.fixedargs)\n    var actdone = spec.done\n\n    if (so.debug.act_caller || so.test) {\n      msg.caller$ = '\\n    Action call arguments and location: ' +\n        (new Error(Util.inspect(msg).replace(/\\n/g, '')).stack)\n          .replace(/.*\\/seneca\\.js:.*\\n/g, '')\n          .replace(/.*\\/seneca\\/lib\\/.*\\.js:.*\\n/g, '')\n    }\n\n    do_act(self, msg, actdone)\n    return self\n  }\n\n\n  function api_wrap (pin, meta, wrapper) {\n    var pinthis = this\n\n    wrapper = _.isFunction(meta) ? meta : wrapper\n    meta = _.isFunction(meta) ? {} : meta\n\n    pin = _.isArray(pin) ? pin : [pin]\n    _.each(pin, function (p) {\n      _.each(pinthis.findpins(p), function (actpattern) {\n        pinthis.add(actpattern, meta, wrapper)\n      })\n    })\n  }\n\n  var handleClose = function () {\n    root.close(function (err) {\n      if (err) {\n        Common.console_error(err)\n      }\n\n      process.exit(err ? (err.exit === null ? 1 : err.exit) : 0)\n    })\n  }\n\n  // close seneca instance\n  // sets public seneca.closed property\n  function api_close (done) {\n    var seneca = this\n\n    seneca.ready(do_close)\n\n    function do_close () {\n      seneca.closed = true\n\n      // cleanup process event listeners\n      _.each(so.internal.close_signals, function (active, signal) {\n        if (active) {\n          process.removeListener(signal, handleClose)\n        }\n      })\n\n      seneca.log.debug({kind: 'close', notice: 'start', callpoint: callpoint()})\n      seneca.act('role:seneca,cmd:close,closing$:true', function (err) {\n        seneca.log.debug(errlog(\n          err, {kind: 'close', notice: 'end'}))\n\n        seneca.removeAllListeners('act-in')\n        seneca.removeAllListeners('act-out')\n        seneca.removeAllListeners('act-err')\n        seneca.removeAllListeners('pin')\n        seneca.removeAllListeners('after-pin')\n        seneca.removeAllListeners('ready')\n\n        if (_.isFunction(done)) {\n          return done.call(seneca, err)\n        }\n      })\n    }\n  }\n\n  // useful when defining services!\n  // note: has EventEmitter.once semantics\n  // if using .on('ready',fn) it will be be called for each ready event\n  function api_ready (ready) {\n    var self = this\n\n    setImmediate(function register_ready () {\n      if (root.private$.ge.isclear()) {\n        ready.call(self)\n      }\n      else {\n        root.private$.ready_list.push(ready.bind(self))\n      }\n    })\n\n    return self\n  }\n\n  // use('pluginname') - built-in, or provide calling code 'require' as seneca opt\n  // use(require('pluginname')) - plugin object, init will be called\n  // if first arg has property senecaplugin\n  function api_use (arg0, arg1, arg2) {\n    var self = this\n    var plugindesc\n\n\n    // DEPRECATED: Remove when Seneca >= 4.x\n    // Allow chaining with seneca.use('options', {...})\n    // see https://github.com/rjrodger/seneca/issues/80\n    if (arg0 === 'options') {\n      self.options(arg1)\n      return self\n    }\n\n    try {\n      plugindesc = private$.use(arg0, arg1, arg2)\n    }\n    catch (e) {\n      self.die(error(e, 'plugin_' + e.code))\n      return self\n    }\n\n    self.register(plugindesc)\n\n    return self\n  }\n\n  // Return self. Mostly useful as a check that this is a Seneca instance.\n  function api_seneca () {\n    return this\n  }\n\n  // Describe this instance using the form: Seneca/VERSION/ID\n  function api_toString () {\n    return this.fullname\n  }\n\n\n  function api_inward (inward) {\n    Assert('function' === typeof inward)\n    Assert(2 === inward.length)\n\n    private$.inward.add(inward)\n    return this\n  }\n\n\n  function api_outward (outward) {\n    Assert('function' === typeof outward)\n    Assert(2 === outward.length)\n\n    private$.outward.add(outward)\n    return this\n  }\n\n\n  function do_act (instance, origmsg, actdone) {\n    var actstart = Date.now()\n    var msg = _.clone(origmsg)\n    var act_callpoint = callpoint()\n    var is_sync = _.isFunction(actdone)\n    var execute_instance = instance\n    var timedout = false\n\n    actdone = actdone || _.noop\n\n    if (msg.gate$) {\n      execute_instance = instance.delegate()\n      execute_instance.private$.ge =\n        execute_instance.private$.ge.gate()\n    }\n\n    var execspec = {\n      fn: function act_fn (done) {\n        try {\n          execute_action(execute_instance, msg, function reply () {\n            if (!timedout) {\n              handle_result.apply(this, arguments)\n            }\n            done()\n          })\n        }\n        catch (e) {\n          handle_result.call(execute_instance, e)\n          done()\n        }\n      },\n      ontm: function act_tm () {\n        timedout = true\n        handle_result.call(execute_instance, new Error('[TIMEOUT]'))\n      },\n      tm: 'number' === typeof msg.timeout$ ? msg.timeout$ : null\n    }\n\n    execute_instance.private$.ge.add(execspec)\n\n\n    var action_ctxt = {}\n\n    function execute_action (act_instance, msg, reply) {\n      var actmeta = act_instance.find(msg, {catchall: so.internal.catchall})\n\n      msg.meta$ = msg.meta$ || {}\n      var delegate = act_make_delegate(act_instance, msg, actmeta)\n\n      action_ctxt.start = actstart\n      action_ctxt.sync = is_sync\n      action_ctxt.seneca = delegate\n      action_ctxt.actmeta = actmeta\n      action_ctxt.options = delegate.options()\n      action_ctxt.callpoint = act_callpoint\n\n      var data = {msg: msg, reply: reply}\n      var inward = private$.inward.process(action_ctxt, data)\n\n      if (handle_inward_break(inward, act_instance, data, actmeta, origmsg)) {\n        return\n      }\n\n      if (!actmeta.sub) {\n        delegate.log.debug(actlog(\n          actmeta, msg, origmsg,\n          { kind: 'act', case: 'IN' }))\n      }\n\n      actmeta.func.call(delegate, data.msg, data.reply)\n    }\n\n\n    function handle_result () {\n      var argsarr = new Array(arguments.length)\n      for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n      if (!so.legacy.action_signature &&\n          1 === argsarr.length &&\n          !_.isError(argsarr[0])) {\n        argsarr.unshift(null)\n      }\n\n      var actmeta = action_ctxt.actmeta\n      var delegate = this || instance\n\n      var actend = Date.now()\n      action_ctxt.duration = actend - action_ctxt.start\n\n      var call_cb = true\n\n      var data = {\n        msg: msg,\n        err: argsarr[0],\n        res: argsarr[1]\n      }\n\n      var outward = private$.outward.process(action_ctxt, data)\n      var err = data.err\n\n      if (outward) {\n        if ('error' === outward.kind) {\n          err = outward.error ||\n            error(outward.code, outward.info)\n        }\n      }\n\n      if (err) {\n        var out = act_error(instance, err, actmeta, argsarr, actdone,\n                            actend - actstart, msg, origmsg, act_callpoint)\n\n        if (msg.fatal$) {\n          return instance.die(out.err)\n        }\n\n        call_cb = out.call_cb\n        argsarr[0] = out.err\n\n        if (delegate && _.isFunction(delegate.on_act_err)) {\n          delegate.on_act_err(actmeta, argsarr[0])\n        }\n      }\n      else {\n        instance.emit('act-out', msg, argsarr[1])\n        argsarr[0] = null\n\n        delegate.log.debug(actlog(\n          actmeta, msg, origmsg,\n          { kind: 'act',\n            case: 'OUT',\n            duration: actend - actstart,\n            result: argsarr[1]\n          }))\n\n        if (_.isFunction(delegate.on_act_out)) {\n          delegate.on_act_out(actmeta, argsarr[1])\n        }\n      }\n\n      try {\n        if (call_cb) {\n          actdone.apply(delegate, argsarr) // note: err == argsarr[0]\n        }\n      }\n\n      // for exceptions thrown inside the callback\n      catch (ex) {\n        var formattedErr = ex\n        // handle throws of non-Error values\n        if (!Util.isError(ex)) {\n          formattedErr = _.isObject(ex)\n            ? new Error(Jsonic.stringify(ex))\n            : new Error('' + ex)\n        }\n\n        callback_error(instance, formattedErr, actmeta, argsarr, actdone,\n                       actend - actstart, msg, origmsg, act_callpoint)\n      }\n    }\n  }\n\n\n  function handle_inward_break (inward, act_instance, data, actmeta, origmsg) {\n    if (!inward) return false\n\n    var msg = data.msg\n    var reply = data.reply\n\n    if ('error' === inward.kind) {\n      var err = inward.error ||\n            error(inward.code, inward.info)\n\n      if (inward.log && inward.log.level) {\n        act_instance.log[inward.log.level](errlog(err, errlog(\n          actmeta || {}, msg.meta$.prior, msg, origmsg, inward.log.data\n        )))\n      }\n\n      reply.call(act_instance, err)\n      return true\n    }\n    else if ('result' === inward.kind) {\n      if (inward.log && inward.log.level) {\n        act_instance.log[inward.log.level](actlog(\n          actmeta || {}, msg, origmsg, inward.log.data\n        ))\n      }\n\n      reply.call(act_instance, null, inward.result)\n      return true\n    }\n  }\n\n\n  function act_error (instance, err, actmeta, result, cb,\n    duration, msg, origmsg, act_callpoint) {\n    var call_cb = true\n    actmeta = actmeta || {}\n\n    if (!err.seneca) {\n      err = error(err, 'act_execute', _.extend(\n        {},\n        err.details,\n        {\n          message: (err.eraro && err.orig) ? err.orig.message : err.message,\n          pattern: actmeta.pattern,\n          fn: actmeta.func,\n          cb: cb,\n          instance: instance.toString()\n        }))\n\n      result[0] = err\n    }\n\n    // Special legacy case for seneca-perm\n    else if (err.orig &&\n      _.isString(err.orig.code) &&\n      err.orig.code.indexOf('perm/') === 0) {\n      err = err.orig\n      result[0] = err\n    }\n\n    err.details = err.details || {}\n    err.details.plugin = err.details.plugin || {}\n\n    var entry = actlog(\n      actmeta, msg, origmsg,\n      {\n        // kind is act as this log entry relates to an action\n        kind: 'act',\n        case: 'ERR',\n        duration: duration\n      })\n    entry = errlog(err, entry)\n\n    instance.log.error(entry)\n    instance.emit('act-err', msg, err)\n\n    // when fatal$ is set, prefer to die instead\n    if (so.errhandler && (!msg || !msg.fatal$)) {\n      call_cb = !so.errhandler.call(instance, err)\n    }\n\n    return {\n      call_cb: call_cb,\n      err: err\n    }\n  }\n\n  function callback_error (instance, err, actmeta, result, cb,\n    duration, msg, origmsg, act_callpoint) {\n    actmeta = actmeta || {}\n\n    if (!err.seneca) {\n      err = error(err, 'act_callback', _.extend(\n        {},\n        err.details,\n        {\n          message: err.message,\n          pattern: actmeta.pattern,\n          fn: actmeta.func,\n          cb: cb,\n          instance: instance.toString()\n        }))\n\n      result[0] = err\n    }\n\n    err.details = err.details || {}\n    err.details.plugin = err.details.plugin || {}\n\n    instance.log.error(actlog(\n      actmeta, msg, origmsg,\n      {\n        // kind is act as this log entry relates to an action\n        kind: 'act',\n        case: 'ERR',\n        info: err.message,\n        code: err.code,\n        err: err,\n        duration: duration\n      }))\n\n    instance.emit('act-err', msg, err, result[1])\n\n    if (so.errhandler) {\n      so.errhandler.call(instance, err)\n    }\n  }\n\n\n  function api_fix () {\n    var self = this\n\n    var defargs = Common.parsePattern(self, arguments)\n\n    var fix = self.delegate(defargs.pattern)\n\n    fix.add = function fix_add () {\n      var args = Common.parsePattern(fix, arguments, 'rest:.*', defargs.pattern)\n      var addargs = [args.pattern].concat(args.rest)\n      return self.add.apply(fix, addargs)\n    }\n\n    return fix\n  }\n\n\n  function api_delegate (fixedargs) {\n    var self = this\n    fixedargs = fixedargs || {}\n\n    var delegate = Object.create(self)\n    delegate.private$ = Object.create(self.private$)\n\n    delegate.did = refnid()\n\n    var strdesc\n    delegate.toString = function toString () {\n      if (strdesc) return strdesc\n      var vfa = {}\n      _.each(fixedargs, function (v, k) {\n        if (~k.indexOf('$')) return\n        vfa[k] = v\n      })\n\n      strdesc = self.toString() +\n        (_.keys(vfa).length ? '/' + Jsonic.stringify(vfa) : '')\n\n      return strdesc\n    }\n\n    delegate.fixedargs = (so.strict.fixedargs\n      ? _.extend({}, fixedargs, self.fixedargs)\n      : _.extend({}, self.fixedargs, fixedargs))\n\n    delegate.delegate = function delegate (further_fixedargs) {\n      var args = _.extend({}, delegate.fixedargs, further_fixedargs || {})\n      return self.delegate.call(this, args)\n    }\n\n    // Somewhere to put contextual data for this delegate.\n    // For example, data for individual web requests.\n    delegate.context = {}\n\n    delegate.client = function client () {\n      return self.client.apply(this, arguments)\n    }\n\n    delegate.listen = function listen () {\n      return self.listen.apply(this, arguments)\n    }\n\n    return delegate\n  }\n\n\n  function api_options (options, chain) {\n    var self = this\n\n    if (options != null) {\n      self.log.debug({\n        kind: 'options',\n        case: 'SET',\n        options: options,\n        callpoint: callpoint()})\n    }\n\n    so = private$.exports.options = ((options == null)\n      ? private$.optioner.get()\n      : private$.optioner.set(options))\n\n    if (so.legacy.logging) {\n      if (options && options.log && _.isArray(options.log.map)) {\n        for (var i = 0; i < options.log.map.length; ++i) {\n          self.logroute(options.log.map[i])\n        }\n      }\n    }\n\n    // Allow chaining with seneca.options({...}, true)\n    // see https://github.com/rjrodger/seneca/issues/80\n    return chain ? self : so\n  }\n\n\n  function api_error (errhandler) {\n    this.options({ errhandler: errhandler })\n    return this\n  }\n\n\n  // TODO: should set all system.close_signals to false\n  function api_test (errhandler, logspec) {\n    if ('function' !== typeof errhandler && null !== errhandler) {\n      logspec = errhandler\n      errhandler = null\n    }\n\n    this.options({\n      errhandler: null === errhandler ? null : (errhandler || console.log),\n      test: true,\n      log: logspec || 'test'\n    })\n\n    private$.logger = load_logger(root, so.internal.logger)\n\n    return this\n  }\n\n  // Inspired by https://github.com/hapijs/hapi/blob/master/lib/plugin.js decorate\n  function api_decorate () {\n    var args = Norma('property:s value:.', arguments)\n\n    // TODO: review; needs to be more universally applicable\n    // also messages should not be embedded directly\n    var property = args.property\n    Assert(property[0] !== '_', 'property cannot start with _')\n    Assert(private$.decorations[property] === undefined, 'seneca is already decorated with the property')\n    Assert(root[property] === undefined, 'cannot override a core seneca property: ' + property)\n\n    root[property] = private$.decorations[property] = args.value\n  }\n\n  // DEPRECATED\n  // for use with async\n  root.next_act = function next_act () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var si = this || root\n\n    si.log.warn({\n      kind: 'notice',\n      case: 'DEPRECATION',\n      notice: Errors.deprecation.seneca_next_act\n    })\n\n\n    return function (next) {\n      argsarr.push(next)\n      si.act.apply(si, argsarr)\n    }\n  }\n\n\n  // TODO: follow api_ convention\n  root.gate = function gate () {\n    return this.delegate({gate$: true})\n  }\n\n\n  // TODO: follow api_ convention\n  root.ungate = function ungate () {\n    this.fixedargs.gate$ = false\n    return this\n  }\n\n\n  // Add builtin actions.\n  root.add({role: 'seneca', cmd: 'stats'}, action_seneca_stats)\n  root.add({role: 'seneca', cmd: 'close'}, action_seneca_close)\n  root.add({role: 'seneca', info: 'fatal'}, action_seneca_fatal)\n  root.add({role: 'seneca', get: 'options'}, action_options_get)\n\n  // Legacy builtin actions.\n  // Remove in Seneca 4.x\n  root.add({role: 'seneca', stats: true, deprecate$: true}, action_seneca_stats)\n  root.add({role: 'options', cmd: 'get', deprecate$: true}, action_options_get)\n\n  Print(root)\n\n  // Define builtin actions.\n\n  function action_seneca_fatal (args, done) {\n    done()\n  }\n\n  function action_seneca_close (args, done) {\n    this.emit('close')\n    done()\n  }\n\n  function action_seneca_stats (args, done) {\n    args = args || {}\n    var stats\n\n    if (args.pattern && private$.stats.actmap[args.pattern]) {\n      stats = private$.stats.actmap[args.pattern]\n      stats.time = private$.timestats.calculate(args.pattern)\n    }\n    else {\n      stats = _.clone(private$.stats)\n      stats.now = new Date()\n      stats.uptime = stats.now - stats.start\n\n      stats.now = new Date(stats.now).toISOString()\n      stats.start = new Date(stats.start).toISOString()\n\n      var summary =\n      (args.summary == null) ||\n        (/^false$/i.exec(args.summary) ? false : !!(args.summary))\n\n      if (summary) {\n        stats.actmap = void 0\n      }\n      else {\n        _.each(private$.stats.actmap, function (a, p) {\n          private$.stats.actmap[p].time = private$.timestats.calculate(p)\n        })\n      }\n    }\n\n    if (done) {\n      done(null, stats)\n    }\n    return stats\n  }\n\n  root.stats = action_seneca_stats\n\n  function action_options_get (args, done) {\n    var options = private$.optioner.get()\n\n    var base = args.base || null\n    var root = base ? (options[base] || {}) : options\n    var val = args.key ? root[args.key] : root\n\n    done(null, Common.copydata(val))\n  }\n\n  _.each(so.internal.close_signals, function (active, signal) {\n    if (active) {\n      process.once(signal, handleClose)\n    }\n  })\n\n  function load_logger (instance, log_plugin) {\n    log_plugin = log_plugin || require('./lib/logging')\n\n    return log_plugin.preload.call(instance).extend.logger\n  }\n\n  function action_queue_clear () {\n    root.emit('ready')\n\n    var ready = root.private$.ready_list.shift()\n    if (ready) {\n      ready()\n    }\n\n    if (root.private$.ge.isclear()) {\n      while (0 < root.private$.ready_list.length) {\n        root.private$.ready_list.shift()()\n      }\n    }\n  }\n\n  return root\n}\n\n\n// Private member variables of Seneca object.\nfunction make_private () {\n  return {\n    stats: {\n      start: Date.now(),\n      act: {\n        calls: 0,\n        done: 0,\n        fails: 0,\n        cache: 0\n      },\n      actmap: {}\n    }\n  }\n}\n\n\n// Callpoint resolver. Indicates location in calling code.\nfunction make_callpoint (active) {\n  if (active) {\n    return function () {\n      return error.callpoint(\n        new Error(),\n        ['/seneca/seneca.js', '/seneca/lib/', '/lodash.js'])\n    }\n  }\n\n  return _.noop\n}\n\n\nfunction make_log (instance, modifier) {\n  var log = instance.log || function log (data) {\n    instance.private$.logger(this, data)\n  }\n\n  log = prepare_log(instance, make_modified_log(log, modifier))\n  make_log_levels(instance, log)\n\n  return log\n}\n\nfunction prepare_log (instance, log) {\n  return function prepare_log_data () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var a0 = argsarr[0]\n    var data = _.isArray(a0) ? a0\n          : _.isObject(a0) ? a0\n          : argsarr\n    log.call(instance, data)\n  }\n}\n\nfunction make_log_levels (instance, log) {\n  function log_level (level) {\n    return function (data) {\n      data.level = level\n    }\n  }\n  log.debug = prepare_log(instance, make_modified_log(log, log_level('debug')))\n  log.info = prepare_log(instance, make_modified_log(log, log_level('info')))\n  log.warn = prepare_log(instance, make_modified_log(log, log_level('warn')))\n  log.error = prepare_log(instance, make_modified_log(log, log_level('error')))\n  log.fatal = prepare_log(instance, make_modified_log(log, log_level('fatal')))\n}\n\nfunction make_modified_log (log, modifier) {\n  return function log_modifier (data) {\n    modifier(data)\n    log.call(this, data)\n  }\n}\n\nfunction default_log_modifier (data) {\n  data.level = null == data.level ? 'debug' : data.level\n  data.seneca = null == data.seneca ? root.id : data.seneca\n  data.when = null == data.when ? Date.now() : data.when\n}\n\n\nfunction act_make_delegate (instance, msg, actmeta) {\n  actmeta = actmeta || {}\n\n  var delegate_args = {\n    plugin$: {\n      name: actmeta.plugin_name,\n      tag: actmeta.plugin_tag\n    }\n  }\n\n  var delegate = instance.delegate(delegate_args)\n\n  // special overrides\n  if (msg.meta$.tx) {\n    delegate.fixedargs.tx$ = msg.meta$.tx\n  }\n\n  // automate actid log insertion\n\n  delegate.log = make_log(delegate, function act_delegate_log_modifier (data) {\n    data.actid = msg.meta$.id\n\n    data.plugin_name = data.plugin_name || actmeta.plugin_name\n    data.plugin_tag = data.plugin_tag || actmeta.plugin_tag\n    data.pattern = data.pattern || actmeta.pattern\n  })\n\n  if (actmeta.priormeta) {\n    // TODO: support Common.parsePattern\n    delegate.prior = function (prior_msg, prior_cb) {\n      prior_msg = _.clone(prior_msg)\n      prior_msg.tx$ = msg.meta$.tx\n      prior_msg.default$ = prior_msg.default$ || msg.default$\n\n      delete prior_msg.id$\n      delete prior_msg.gate$\n      delete prior_msg.actid$\n      delete prior_msg.meta$\n      delete prior_msg.transport$\n\n      prior_msg.meta$ = {}\n      prior_msg.meta$.start = Date.now()\n      prior_msg.meta$.sync = msg.meta$.sync\n\n      prior_msg.meta$.prior = _.clone(msg.meta$.prior)\n      prior_msg.meta$.prior.chain = _.clone(msg.meta$.prior.chain)\n      prior_msg.meta$.prior.chain.push(actmeta.id)\n      prior_msg.meta$.prior.entry = false\n      prior_msg.meta$.prior.depth++\n\n      var prior_action_ctxt = {\n        actmeta: actmeta.priormeta\n      }\n\n      // TODO: handle inward result\n      delegate.private$.inward.process(\n        {tags: ['prior']},\n        prior_action_ctxt, {msg: msg})\n\n      var pd = act_make_delegate(delegate, msg, actmeta.priormeta)\n      actmeta.priormeta.func.call(pd, prior_msg, prior_cb.bind(pd))\n    }\n\n    delegate.parent = function (prior_msg, prior_cb) {\n      delegate.log.warn({\n        kind: 'notice',\n        case: 'DEPRECATION',\n        notice: Errors.deprecation.seneca_parent\n      })\n      delegate.prior(prior_msg, prior_cb)\n    }\n  }\n  else {\n    delegate.prior = function (msg, done) {\n      var out = msg.default$ ? msg.default$ : null\n      return done.call(delegate, null, out)\n    }\n  }\n\n  return delegate\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/actions.js":"/* Copyright (c) 2010-2017 Richard Rodger and other contributors, MIT License */\n'use strict'\n\n\nvar Util = require('util')\nvar Assert = require('assert')\n\n\nvar _ = require('lodash')\nvar Jsonic = require('jsonic')\n\n\nvar Common = require('./common')\n\n\n// Find the action metadata for a given pattern, if it exists.\nexports.find = function (pattern, flags) {\n  var seneca = this\n\n  var pat = _.isString(pattern) ? Jsonic(pattern) : pattern\n  pat = seneca.util.clean(pat)\n  pat = pat || {}\n\n  var actmeta = seneca.private$.actrouter.find(pat)\n\n  if (!actmeta && flags && flags.catchall) {\n    actmeta = seneca.private$.actrouter.find({})\n  }\n\n  return actmeta\n}\n\n\n// True if an action matching the pattern exists.\nexports.has = function (pattern) {\n  return !!exports.find.call(this, pattern)\n}\n\n\n// List all actions that match the pattern.\nexports.list = function (pattern) {\n  var pat = _.isString(pattern) ? Jsonic(pattern) : pattern\n  var found = this.private$.actrouter.list(pat)\n  found = _.map(found, 'match')\n  return found\n}\n\n\nexports.inward = {\n  closed: inward_closed,\n  resolve_msg_id: inward_resolve_msg_id,\n  act_cache: inward_act_cache,\n  act_default: inward_act_default,\n  act_not_found: inward_act_not_found,\n  validate_msg: inward_validate_msg,\n  warnings: inward_warnings,\n  msg_meta: inward_msg_meta,\n  msg_modify: inward_msg_modify,\n  act_stats: inward_act_stats,\n  prepare_delegate: inward_prepare_delegate,\n  announce: inward_announce\n}\n\n\nexports.outward = {\n  act_cache: outward_act_cache,\n  res_object: outward_res_object,\n  act_stats: outward_act_stats\n}\n\n\nfunction inward_announce (ctxt, data) {\n  if (!ctxt.actmeta) return\n\n  if (_.isFunction(ctxt.seneca.on_act_in)) {\n    ctxt.seneca.on_act_in(ctxt.actmeta, data.msg)\n  }\n\n  ctxt.seneca.emit('act-in', data.msg)\n}\n\n\nfunction inward_closed (ctxt, data) {\n  if (ctxt.seneca.closed && !data.msg.closing$) {\n    return {\n      kind: 'error',\n      code: 'closed',\n      info: {\n        args: Util.inspect(Common.clean(data.msg)).replace(/\\n/g, '')\n      }\n    }\n  }\n}\n\n\nfunction inward_resolve_msg_id (ctxt, data) {\n  var msg = data.msg\n\n  var id_tx = (msg.id$ ||\n               msg.actid$ ||\n               msg.meta$.id ||\n               ctxt.seneca.idgen())\n        .split('/')\n\n  var tx =\n        id_tx[1] ||\n        msg.tx$ ||\n        msg.meta$.tx$ ||\n        ctxt.seneca.fixedargs.tx$ ||\n        ctxt.seneca.idgen()\n\n  var mi = (id_tx[0] || ctxt.seneca.idgen())\n\n  msg.meta$.mi = mi\n  msg.meta$.tx = tx\n  msg.meta$.id = mi + '/' + tx\n}\n\n\nfunction inward_act_stats (ctxt, data) {\n  if (!ctxt.actmeta) {\n    return\n  }\n\n  var private$ = ctxt.seneca.private$\n  ++private$.stats.act.calls\n\n  var pattern = ctxt.actmeta.pattern\n\n  var actstats = (private$.stats.actmap[pattern] =\n                  private$.stats.actmap[pattern] || {})\n\n\n  ++actstats.calls\n}\n\n\nfunction outward_act_stats (ctxt, data) {\n  if (!ctxt.actmeta || ctxt.cached$) {\n    return\n  }\n\n  var private$ = ctxt.seneca.private$\n  ++private$.stats.act.done\n\n  var msg = data.msg\n\n  if (msg &&\n      msg.meta$ &&\n      msg.meta$.prior &&\n      msg.meta$.prior.entry\n     ) {\n    private$.timestats.point(ctxt.duration, ctxt.actmeta.pattern)\n  }\n\n  var pattern = ctxt.actmeta.pattern\n\n  var actstats = (private$.stats.actmap[pattern] =\n                  private$.stats.actmap[pattern] || {})\n\n\n  if (data.err) {\n    private$.stats.act.fails++\n    ++actstats.fails\n  }\n  else {\n    ++actstats.done\n  }\n}\n\n\nfunction inward_act_default (ctxt, data) {\n  var so = ctxt.options\n  var msg = data.msg\n\n  // TODO: existence of pattern action needs own indicator flag\n  if (!ctxt.actmeta) {\n    var default$ = msg.default$ || (!so.strict.find ? {} : msg.default$)\n\n    if (_.isPlainObject(default$) || _.isArray(default$)) {\n      return {\n        kind: 'result',\n        result: default$,\n        log: {\n          level: 'debug',\n          data: {\n            kind: 'act',\n            case: 'DEFAULT'\n          }\n        }\n      }\n    }\n\n    else if (null != default$) {\n      return {\n        kind: 'error',\n        code: 'act_default_bad',\n        info: {\n          args: Util.inspect(Common.clean(msg)).replace(/\\n/g, ''),\n          xdefault: Util.inspect(default$)\n        }\n      }\n    }\n  }\n}\n\n\nfunction inward_act_not_found (ctxt, data) {\n  var so = ctxt.options\n  var msg = data.msg\n\n  if (!ctxt.actmeta) {\n    return {\n      kind: 'error',\n      code: 'act_not_found',\n      info: { args: Util.inspect(Common.clean(msg)).replace(/\\n/g, '') },\n      log: {\n        level: so.trace.unknown ? 'warn' : 'debug',\n        data: {\n          kind: 'act',\n          case: 'UNKNOWN'\n        }\n      }\n    }\n  }\n}\n\n\nfunction inward_validate_msg (ctxt, data) {\n  var so = ctxt.options\n  var msg = data.msg\n\n  Assert(ctxt.actmeta)\n\n  if (!_.isFunction(ctxt.actmeta.validate)) {\n    return\n  }\n\n  var err = null\n\n  // FIX: this is assumed to be synchronous\n  // seneca-parambulator and seneca-joi need to be updated\n  ctxt.actmeta.validate(msg, function (verr) {\n    err = verr\n  })\n\n  if (err) {\n    return {\n      kind: 'error',\n      code: so.legacy.error_codes ? 'act_invalid_args' : 'act_invalid_msg',\n      info: {\n        pattern: ctxt.actmeta.pattern,\n        message: err.message,\n        msg: Common.clean(msg),\n        error: err\n      },\n      log: {\n        level: so.trace.invalid ? 'warn' : null,\n        data: {\n          kind: 'act',\n          case: 'INVALID'\n        }\n      }\n\n    }\n  }\n}\n\n\n// Check if actid has already been seen, and if action cache is active,\n// then provide cached result, if any. Return true in this case.\nfunction inward_act_cache (ctxt, data) {\n  var so = ctxt.options\n  var msg = data.msg\n\n  var actid = msg.meta$.id\n  var private$ = ctxt.seneca.private$\n\n  if (actid != null && so.actcache.active) {\n    var actdetails = private$.actcache.get(actid)\n\n    if (actdetails) {\n      private$.stats.act.cache++\n\n      var err = actdetails.result[0]\n      var res = actdetails.result[1]\n\n      var out = {\n        kind: err ? 'error' : 'result',\n        result: res || null,\n        error: err || null,\n        log: {\n          level: 'debug',\n          data: {\n            kind: 'act',\n            case: 'CACHE'\n          }\n        }\n      }\n\n      ctxt.cached$ = true\n\n      return out\n    }\n  }\n}\n\n\n// Store result in action cache\nfunction outward_act_cache (ctxt, data) {\n  var so = ctxt.options\n  var msg = data.msg\n  var res = data.res\n  var err = data.err\n\n  var actid = msg.meta$.id\n  var private$ = ctxt.seneca.private$\n\n  if (actid != null && so.actcache.active) {\n    private$.actcache.set(actid, {\n      result: [err, res],\n      actmeta: ctxt.actmeta,\n      when: Date.now()\n    })\n  }\n}\n\n\nfunction inward_warnings (ctxt, data) {\n  var so = ctxt.options\n  var msg = data.msg\n\n  Assert(ctxt.actmeta)\n\n  if (so.debug.deprecation && ctxt.actmeta.deprecate) {\n    ctxt.seneca.log.warn({\n      kind: 'act',\n      case: 'DEPRECATED',\n      msg: msg,\n      pattern: ctxt.actmeta.pattern,\n      notice: ctxt.actmeta.deprecate,\n      callpoint: ctxt.callpoint\n    })\n  }\n}\n\n\nfunction inward_msg_meta (ctxt, data) {\n  var msg = data.msg\n\n  Assert(ctxt.actmeta)\n\n  msg.meta$.pattern = ctxt.actmeta.pattern\n  msg.meta$.action = ctxt.actmeta.id\n  msg.meta$.plugin_name = ctxt.actmeta.plugin_name\n  msg.meta$.plugin_tag = ctxt.actmeta.plugin_tag\n\n  msg.meta$.prior = msg.meta$.prior || { chain: [], entry: true, depth: 0 }\n  msg.meta$.start = ctxt.start\n  msg.meta$.sync = ctxt.sync\n}\n\n\nfunction inward_msg_modify (ctxt, data) {\n  data.msg = _.extend(\n    data.msg,\n    ctxt.seneca.fixedargs,\n    {tx$: data.msg.meta$.tx}\n  )\n\n  // remove actid so that user manipulation of msg for subsequent use does\n  // not cause inadvertent hit on existing action\n  delete data.msg.id$\n  delete data.msg.actid$ // legacy alias\n}\n\n\nfunction inward_prepare_delegate (ctxt, data) {\n  data.reply = data.reply.bind(ctxt.seneca)\n  data.reply.seneca = ctxt.seneca\n\n  var reply = data.reply\n\n  ctxt.seneca.good = function good (out) {\n    reply(null, out)\n  }\n\n  ctxt.seneca.bad = function bad (err) {\n    reply(err)\n  }\n}\n\n\nfunction outward_res_object (ctxt, data) {\n  var so = ctxt.options\n  var msg = data.msg\n  var res = data.res\n  var err = data.err\n\n  var not_object =\n        err == null &&\n        res != null &&\n        !(_.isPlainObject(res) ||\n          _.isArray(res) ||\n          !!res.entity$ ||\n          !!res.force$)\n\n  var not_legacy =\n        !(msg.cmd === 'generate_id' ||\n          msg.note === true ||\n          msg.cmd === 'native' ||\n          msg.cmd === 'quickcode')\n\n  if (so.strict.result && not_legacy && not_object) {\n    return {\n      kind: 'error',\n      code: 'result_not_objarr',\n      info: {\n        pattern: ctxt.actmeta.pattern,\n        args: Util.inspect(Common.clean(msg)).replace(/\\n/g, ''),\n        result: res\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/common.js":"/* Copyright (c) 2010-2016 Richard Rodger and other contributors, MIT License */\n'use strict'\n\n\nvar Util = require('util')\nvar _ = require('lodash')\nvar Eraro = require('eraro')\nvar Jsonic = require('jsonic')\nvar Nid = require('nid')\nvar Norma = require('norma')\nvar Errors = require('./errors')\n\n\nvar internals = {\n  error: Eraro({\n    package: 'seneca',\n    msgmap: Errors,\n    override: true\n  })\n}\n\n\nexports.boolify = function (v) {\n  try {\n    return !!JSON.parse(v)\n  }\n  catch (e) {\n    return !!v\n  }\n}\n\n\nexports.tagnid = Nid({length: 3, alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'})\n\n\nexports.delegate = function (scope, func) {\n  var args = Array.prototype.slice.call(arguments, 2)\n  return function () {\n    return func.apply(scope, args.concat(Array.prototype.slice.call(arguments)))\n  }\n}\n\n// use args properties as fields\n// defaults: map of default values\n// args: args object\n// fixed: map of fixed values - cannot be overriden\n// omits: array of prop names to exclude\n// defaults, args, and fixed are deepextended together in that order\nexports.argprops = function argprops (defaults, args, fixed, omits) {\n  omits = _.isArray(omits) ? omits\n    : _.isObject(omits) ? _.keys(omits)\n    : _.isString(omits) ? omits.split(/\\s*,\\s*/)\n    : '' + omits\n\n  // a little pre omit to avoid entities named in omits\n  var usedargs = _.omit(args, omits)\n\n  // don't support $ args\n  usedargs = clean(usedargs)\n\n  return _.omit(deepextend(defaults, usedargs, fixed), omits)\n}\n\n\n// string args override object args\nexports.parsePattern = function parse_pattern (instance, args, normaspec, fixed) {\n  args =\n    Norma('{strargs:s? objargs:o? moreobjargs:o? ' + (normaspec || '') + '}', args)\n\n  try {\n    return _.extend(\n      args,\n      { pattern: _.extend(\n          {},\n\n          // Precedence of arguments in add,act is left-to-right\n          args.moreobjargs ? args.moreobjargs : {},\n          args.objargs ? args.objargs : {},\n          args.strargs ? Jsonic(args.strargs) : {},\n\n          fixed || {})\n      })\n  }\n  catch (e) {\n    var col = (e.line === 1) ? e.column - 1 : e.column\n    throw internals.error('add_string_pattern_syntax', {\n      argstr: args,\n      syntax: e.message,\n      line: e.line,\n      col: col\n    })\n  }\n}\n\n\nvar copydata = exports.copydata = function (obj) {\n  var copy\n\n  // Handle the 3 simple types, and null or undefined\n  if (obj === null || typeof obj !== 'object') return obj\n\n  // Handle Date\n  if (_.isDate(obj)) {\n    copy = new Date()\n    copy.setTime(obj.getTime())\n    return copy\n  }\n\n  // Handle Array\n  if (_.isArray(obj)) {\n    copy = []\n    for (var i = 0, len = obj.length; i < len; ++i) {\n      copy[i] = copydata(obj[i])\n    }\n    return copy\n  }\n\n  // Handle Object\n  if (_.isObject(obj)) {\n    copy = {}\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) copy[attr] = copydata(obj[attr])\n    }\n    return copy\n  }\n\n  throw new Error(\"Unable to copy obj! Its type isn't supported.\")\n}\n\n\n// Convert pattern object into a normalized jsonic String.\nvar pattern = exports.pattern = function pattern (patobj) {\n  if (_.isString(patobj)) {\n    return patobj\n  }\n\n  patobj = patobj || {}\n  var sb = []\n  _.each(patobj, function (v, k) {\n    if (!~k.indexOf('$') && !_.isFunction(v)) {\n      sb.push(k + ':' + v)\n    }\n  })\n\n  sb.sort()\n\n  return sb.join(',')\n}\n\nexports.pincanon = function pincanon (inpin) {\n  if (_.isString(inpin)) {\n    return pattern(Jsonic(inpin))\n  }\n  else if (_.isArray(inpin)) {\n    var pin = _.map(inpin, pincanon)\n    pin.sort()\n    return pin.join(';')\n  }\n  else {\n    return pattern(inpin)\n  }\n}\n\n\n// noop for callbacks\nexports.nil = function nil () {\n  _.each(arguments, function (arg) {\n    if (_.isFunction(arg)) {\n      return arg()\n    }\n  })\n}\n\n\n// remove any props containing $\nfunction clean (obj) {\n  if (obj === null) return obj\n\n  return _.pickBy(obj, function (val, prop) {\n    return !_.includes(prop, '$')\n  })\n}\nexports.clean = clean\n\n\nfunction deepextend () {\n  var argsarr = new Array(arguments.length)\n  for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n  // Lodash uses the reverse order to apply defaults than the deepextend API.\n  argsarr = argsarr.reverse()\n\n  // Add an empty object to the front of the args.  Defaults will be written\n  // to this empty object.\n  argsarr.unshift({})\n\n  return _.defaultsDeep.apply(_, argsarr)\n}\nexports.deepextend = deepextend\n\n\n// loop over a list of items recursively\n// list can be an integer - number of times to recurse\nexports.recurse = function recurse (list, work, done) {\n  var ctxt = this\n\n  if (_.isNumber(list)) {\n    list = _.range(0, list)\n  }\n  else {\n    list = _.clone(list)\n  }\n\n  function next (err, out) {\n    if (err) return done(err, out)\n\n    var item = list.shift()\n\n    if (void 0 !== item) {\n      work.call(ctxt, item, next)\n    }\n    else {\n      done.call(ctxt, err, out)\n    }\n  }\n  next.call(ctxt)\n}\n\n\n// Print action result\nexports.print = function print (err, out) {\n  if (err) { console.log('ERROR: ' + err.message) }\n  else { console.log(Util.inspect(out, {depth: null})) }\n}\n\n\nexports.makedie = function (instance, ctxt) {\n  ctxt = _.extend(ctxt, instance.die ? instance.die.context : {})\n\n  var die = function (err) {\n    var die_trace = '\\n' + (new Error('die trace').stack)\n        .match(/^.*?\\n.*\\n(.*)/)[1]\n\n    try {\n      if (!err) {\n        err = new Error('unknown')\n      }\n      else if (!Util.isError(err)) {\n        err = new Error(_.isString(err) ? err : Util.inspect(err))\n      }\n\n      err.fatal$ = true\n\n      var so = instance.options()\n\n      // undead is only for testing, do not use in production\n      var undead = (so.debug && so.debug.undead) || (err && err.undead)\n\n      var logdesc = {\n        kind: ctxt.txt,\n        plugin: ctxt.plugin,\n        tag: ctxt.tag,\n        id: ctxt.id,\n        code: err.code,\n        notice: err.message,\n        err: err,\n        callpoint: ctxt.callpoint()\n      }\n\n      instance.log.fatal.apply(instance, logdesc)\n\n      var stack = err.stack || ''\n      stack = stack.replace(/^.*?\\n/, '\\n')\n\n      var procdesc = '\\n  pid=' + process.pid +\n        ', arch=' + process.arch +\n        ', platform=' + process.platform +\n        ',\\n  path=' + process.execPath +\n        ',\\n  argv=' + Util.inspect(process.argv).replace(/\\n/g, '') +\n        ',\\n  env=' + Util.inspect(process.env).replace(/\\n/g, '')\n\n      var fatalmodemsg = instance.fixedargs.fatal$\n        ? '\\n  ALL ERRORS FATAL: action called with argument fatal$:true ' +\n        '(probably a plugin init error, or using a plugin seneca instance)' : ''\n\n      var stderrmsg =\n      '\\n\\n' +\n        'Seneca Fatal Error\\n' +\n        '==================\\n\\n' +\n        'Message: ' + err.message + '\\n\\n' +\n        'Code: ' + err.code + '\\n\\n' +\n        'Details: ' + Util.inspect(err.details, {depth: null}) + '\\n\\n' +\n        'Stack: ' + stack + '\\n\\n' +\n        'Instance: ' + instance.toString() + fatalmodemsg + die_trace + '\\n\\n' +\n        'When: ' + new Date().toISOString() + '\\n\\n' +\n        'Log: ' + Jsonic.stringify(logdesc) + '\\n\\n' +\n        'Node:\\n  ' + Util.inspect(process.versions).replace(/\\s+/g, ' ') +\n        ',\\n  ' + Util.inspect(process.features).replace(/\\s+/g, ' ') +\n        ',\\n  ' + Util.inspect(process.moduleLoadList).replace(/\\s+/g, ' ') + '\\n\\n' +\n        'Process: ' + procdesc + '\\n\\n'\n\n      if (so.errhandler) {\n        so.errhandler.call(instance, err)\n      }\n\n      if (instance.closed) {\n        return\n      }\n\n      if (!undead) {\n        instance.act('role:seneca,info:fatal,closing$:true', {err: err})\n\n        instance.close(\n          // terminate process, err (if defined) is from seneca.close\n          function (err) {\n            if (!undead) {\n              process.nextTick(function () {\n                if (err) {\n                  exports.console_error(err)\n                }\n\n                exports.console_error(stderrmsg)\n                exports.console_error('\\n\\nSENECA TERMINATED at ' + (new Date().toISOString()) +\n                  '. See above for error report.\\n\\n')\n                process.exit(1)\n              })\n            }\n          }\n       )\n      }\n\n      // make sure we close down within options.deathdelay seconds\n      if (!undead) {\n        var killtimer = setTimeout(function () {\n          exports.console_error(stderrmsg)\n          exports.console_error('\\n\\nSENECA TERMINATED (on timeout) at ' +\n            (new Date().toISOString()) + '.\\n\\n')\n          process.exit(2)\n        }, so.deathdelay)\n        killtimer.unref()\n      }\n    }\n    catch (panic) {\n      var msg =\n      '\\n\\n' +\n        'Seneca Panic\\n' +\n        '============\\n\\n' +\n        panic.stack +\n        '\\n\\nOriginal Error:\\n' +\n        (arguments[0] && arguments[0].stack ? arguments[0].stack : arguments[0])\n      exports.console_error(msg)\n    }\n  }\n\n  die.context = ctxt\n\n  return die\n}\n\n\n// Intentional console errors use this function. Helps to find spurious debugging.\nexports.console_error = function () {\n  console.error.apply(null, arguments)\n}\n\n\nexports.make_standard_act_log_entry = function\n(actmeta, msg, origmsg, ctxt) {\n  var transport = origmsg.transport$ || {}\n  var callmeta = msg.meta$ || {}\n  var prior = callmeta.prior || {}\n  actmeta = actmeta || {}\n\n  return _.extend({\n    actid: callmeta.id,\n    msg: msg,\n    entry: prior.entry,\n    prior: prior.chain,\n    gate: origmsg.gate$,\n    caller: origmsg.caller$,\n    meta: actmeta,\n\n    // these are transitional as need to be updated\n    // to standard transport metadata\n    client: actmeta.client,\n    listen: !!transport.origin,\n    transport: transport\n  }, ctxt)\n}\n\n\nexports.make_standard_err_log_entry = function\n(err, ctxt) {\n  if (!err) return ctxt\n\n  return _.extend({\n    notice: err.message,\n    code: err.code,\n    err: err\n  }, ctxt)\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/errors.js":"/* Copyright (c) 2010-2015 Richard Rodger, MIT License */\n'use strict'\n\n// Error code messages.\nmodule.exports = {\n  test_msg: 'Test message.',\n\n  test_prop: 'TESTING: exists: <%=exists%>, notfound:<%=notfound%>, str=<%=str%>,' +\n    ' obj=<%=obj%>, arr=<%=arr%>, bool=<%=bool%>, null=<%=null$%>, delete=<%=delete$%>, undefined=<%=undefined$%>, void=<%=void$%>, NaN=<%=NaN$%>',\n\n  add_string_pattern_syntax: 'Could not add action due to syntax error in ' +\n    'pattern string: \"<%=argstr%>\": Line:<%=line%>, Column:<%=col%>; <%=syntax%>',\n\n  act_string_args_syntax: 'Could execute action due to syntax error in argument' +\n    ' string: \"<%=argstr%>\": Line:<%=line%>, Column:<%=col%>; <%=syntax%>',\n\n  add_pattern_object_expected_after_string_pattern: 'Could not add action; ' +\n    'unexpected argument; a pattern object or function should follow the pattern' +\n    ' string; arguments were: \"<%=args%>\".',\n\n  add_pattern_object_expected: 'Could not add action; unexpected argument; ' +\n    'a pattern object or string should be the first argument; ' +\n    'arguments were: \"<%=args%>\".',\n\n  add_action_function_expected: 'Could not add action: the action function ' +\n    'should appear after the pattern; arguments were: \"<%=args%>\".',\n\n  add_action_metadata_not_an_object: 'Could not add action: the argument after ' +\n    'the action function should be a metadata object: <%=actmeta%>.',\n\n  add_empty_pattern: 'Could not add action, as the action pattern is empty: ' +\n    '\"<%=args%>\"',\n\n  act_if_expects_boolean: 'The method act_if expects a boolean value as its ' +\n    'first argument, was: \"<%=first%>\".',\n\n  act_not_found: 'No matching action pattern found for <%=args%>, and no default ' +\n    'result provided (using a default$ property).',\n\n  act_default_bad: 'No matching action pattern found for <%=args%>, and default ' +\n    'result is not a plain object or an array: <%=xdefault%>.',\n\n  act_no_args: 'No action pattern defined in \"<%=args%>\"; the first argument ' +\n    'should be a string or object pattern.',\n\n  act_invalid_msg: 'Action <%=pattern%> received an invalid message; <%=message%>; ' +\n    'message content was: <%=msg%>.',\n\n  act_execute: 'Action <%=pattern%> failed: <%=message%>.',\n\n  act_callback: 'Action <%=pattern%> callback threw: <%=message%>.',\n\n  act_loop: 'Action <%=pattern%> loops back on itself. Action details: <%=actmeta%>, history: <%=history%>',\n\n  result_not_objarr: 'Action <%=pattern%> responded with result that was not an ' +\n    'object or array: <%=result%>; Use option strict:{result:false} to allow; ' +\n    'arguments were: <%=args%>',\n\n  no_client: 'Transport client was not created; arguments were: \"<%=args%>\".',\n\n  invalid_options: 'Invalid options; <%=message%>',\n\n  plugin_required: 'The <%=name%> plugin depends on the <%=dependency%> plugin, ' +\n    'which is not loaded yet.',\n\n  plugin_init: 'The <%=name%> plugin failed to initialize: <%=plugin_error%>.',\n\n  plugin_init_timeout: 'The <%=name%> plugin failed to initialize within ' +\n    '<%=timeout%> milliseconds (The init:<%=name%> action did not call the \"done\"' +\n    ' callback in time).',\n\n  export_not_found: 'The export <%=key%> has not been defined by a plugin.',\n\n  store_cmd_missing: 'Entity data store implementation is missing a command; ' +\n    '\"<%=cmd%>\": \"<%=store%>\".',\n\n  sub_function_catch: 'Pattern subscription function threw: <%=message%> on ' +\n    'args: <%=args%>, result: <%=result%>.',\n\n  ready_failed: 'Ready function failed: <%=message%>',\n\n  // Legacy error message codes\n\n  act_invalid_args: 'Action <%=pattern%> has invalid arguments; <%=message%>; ' +\n    'arguments were: <%=msg%>.'\n}\n\n\nmodule.exports.deprecation = {\n  seneca_parent: 'Seneca.parent has been renamed to Seneca.prior. Seneca.parent will be removed in Seneca 4.x.',\n\n  seneca_next_act: 'Seneca.next_act will be removed in Seneca 3.x'\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/legacy.js":"/* Copyright (c) 2010-2016 Richard Rodger and other contributors, MIT License */\n'use strict'\n\nvar _ = require('lodash')\nvar Eraro = require('eraro')\nvar Common = require('./common')\nvar Errors = require('./errors')\n\nvar internals = {\n  error: Eraro({\n    package: 'seneca',\n    msgmap: Errors,\n    override: true\n  })\n}\n\nexports.fail = function make_legacy_fail (so) {\n  return function () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var cb = _.isFunction(argsarr[argsarr.length - 1])\n      ? argsarr[argsarr.length - 1] : null\n\n    if (cb) {\n      argsarr.pop()\n    }\n\n    if (_.isObject(argsarr[0])) {\n      var code = argsarr[0].code\n      if (_.isString(code)) {\n        argsarr.unshift(code)\n      }\n    }\n\n    var err = internals.error.apply(null, argsarr)\n    err.callpoint = new Error().stack.match(/^.*\\n.*\\n\\s*(.*)/)[1]\n    err.seneca = { code: err.code, valmap: err.details }\n\n    this.log.error(Common.make_standard_err_log_entry(err))\n    if (so.errhandler) {\n      so.errhandler.call(this, err)\n    }\n\n    if (cb) {\n      cb.call(this, err)\n    }\n\n    return err\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/optioner.js":"/* Copyright (c) 2014-2016 Richard Rodger and other contributors, MIT License */\n'use strict'\n\nvar Fs = require('fs')\nvar _ = require('lodash')\nvar Error = require('eraro')\nvar Jsonic = require('jsonic')\nvar Minimist = require('minimist')\nvar Common = require('./common')\n\nvar error = Error({ package: 'seneca', msgmap: ERRMSGMAP() })\n\n\nmodule.exports = function (callmodule, defaults, orig_initial) {\n\n  var sourcemap = {\n    argv: {},\n    env: {},\n    default_file: {},\n    loaded: {}\n  }\n\n  // Must be defined here as prepare depends on it.\n  var options = {}\n\n  var basemodule = orig_initial.module || callmodule.parent || callmodule\n  options = prepare(basemodule, defaults, orig_initial)\n\n  // Not needed after this point, and screws up debug printing.\n  delete options.module\n\n\n  function prepare (basemodule, defaults, initial) {\n    var DEFAULT_OPTIONS_FILE = './seneca.options.js'\n    var FATAL_OPTIONS_FILE = './options.seneca.js'\n\n    // Load from custom file, either by providing a string,\n    // or having a property 'from' that is a string.\n    // The string is interpreted as a file path.\n\n    var from = initial.from\n    if (_.isString(initial)) {\n      from = initial\n      initial = {}\n    }\n\n    if (_.isString(from)) {\n      sourcemap.loaded = load_options(from)\n    }\n\n\n    var argv = Minimist(process.argv.slice(2))\n\n\n    if (Fs.existsSync(FATAL_OPTIONS_FILE)) {\n      throw error('inverted_file_name', {\n        from: FATAL_OPTIONS_FILE, module: basemodule\n      })\n    }\n\n    try {\n      sourcemap.default_file = basemodule.require(DEFAULT_OPTIONS_FILE)\n    }\n    catch (e) {\n      if (e.code !== 'MODULE_NOT_FOUND') {\n        var wrappedError = {\n          errmsg: e.message,\n          from: DEFAULT_OPTIONS_FILE,\n          module: basemodule\n        }\n\n        throw error(e, 'require_default_options', wrappedError)\n      }\n    }\n\n    if (process.env.SENECA_OPTIONS) {\n      sourcemap.env = Common.deepextend({}, sourcemap.env,\n                                        Jsonic(process.env.SENECA_OPTIONS))\n    }\n\n    if (argv.seneca) {\n      if (_.isObject(argv.seneca.options)) {\n        sourcemap.argv = argv.seneca.options\n      }\n      else if (_.isString(argv.seneca.options)) {\n        if (argv.seneca.options === 'print') {\n          sourcemap.argv = { debug: {print: {options: true}} }\n        }\n        else {\n          sourcemap.argv = Jsonic(argv.seneca.options)\n        }\n      }\n\n      if (_.isString(sourcemap.argv.from)) {\n        sourcemap.argv = Common.deepextend(load_options(sourcemap.argv.from),\n                                           sourcemap.argv)\n      }\n\n      if (null != argv.seneca.tag) {\n        sourcemap.argv.tag = '' + argv.seneca.tag\n      }\n\n      if (argv.seneca.log) {\n        sourcemap.argv.log = sourcemap.argv.log || {}\n        parse_command_line(argv.seneca.log, sourcemap.argv)\n      }\n    }\n\n    // This is the list of option sources.\n    // The list is in reverse precedence order,\n    // i.e. command line arguments (argv) win\n    var out = Common.deepextend(\n      {},\n      defaults,\n      sourcemap.default_file,\n      options,\n      sourcemap.loaded,\n      initial,\n      sourcemap.env,\n      sourcemap.argv\n    )\n\n    // Legacy log settings.\n    out.log = out.log || out.logger || out.logging || {}\n\n    // boolean corrections\n    out.legacy.logging = Common.boolify(out.legacy.logging)\n\n    return out\n  }\n\n\n  function parse_command_line (spec, parsedSpec) {\n    var logSpec = _.isArray(spec) ? spec[0] : spec\n\n    if (_.isString(logSpec)) {\n      try {\n        parsedSpec.log = Jsonic(logSpec)\n      }\n      catch (e) {\n        parsedSpec.log = {}\n      }\n      return\n    }\n\n    if (_.isObject(logSpec)) {\n      parsedSpec.log = {}\n      var logType = Object.keys(logSpec.level || logSpec)\n      if (logType.length > 0) {\n        parsedSpec.log = { level: logType[0] }\n      }\n    }\n  }\n\n\n  function set_options (input) {\n    if (null == input) throw error('no_options')\n\n    // DEPRECATED: Remove when Seneca >= 4.x\n    if (_.isString(input)) {\n      options = prepare(basemodule, defaults, input)\n    }\n    else {\n      options = Common.deepextend(options, input)\n    }\n\n    return options\n  }\n\n\n  function get_options () {\n    return options\n  }\n\n\n  function load_options (from) {\n    var out = {}\n\n\n    if (from.match(/\\.json$/i)) {\n      // this is deliberate, options are ALWAYS loaded synchronously\n      var text = Fs.readFileSync(from).toString()\n      out = Jsonic(text)\n    }\n    else if (from.match(/\\.js$/i)) {\n      if (!from.match(/^\\//)) {\n        from = './' + from\n      }\n\n      try {\n        out = basemodule.require(from)\n      }\n      catch (e) {\n        if (e.code !== 'MODULE_NOT_FOUND') {\n          throw error(e, 'require_options', { from: from, module: basemodule })\n        }\n      }\n    }\n\n    return out\n  }\n\n\n  return {\n    set: set_options,\n    get: get_options\n  }\n}\n\n\nfunction ERRMSGMAP () {\n  return {\n    inverted_file_name: 'Please use seneca.options.js as the default options ' +\n      'file name. The alternate name options.seneca.js is not supported.',\n\n    require_default_options: 'Call to require failed for <%=from%>: <%=errmsg%>.'\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/plugins.js":"/* Copyright (c) 2014-2015 Richard Rodger, MIT License */\n'use strict'\n\nvar Util = require('util')\nvar _ = require('lodash')\nvar Eraro = require('eraro')\nvar Common = require('./common')\n\nvar internals = {\n  error: Eraro({\n    package: 'seneca',\n    msgmap: {\n      unsupported_legacy_plugin: 'The plugin <%=name%> uses an unsupported legacy ' +\n        'callback to indicate plugin definition is complete: <%=init_func_sig%> ' +\n        '... }. The correct format is: function(options) { ... }. For more details, ' +\n        'please see http://senecajs.org/tutorials/how-to-write-a-plugin.html'\n    }\n  })\n}\n\nmodule.exports.register = function (so, callpoint) {\n  var seq = 0\n\n  return function api_register (plugin) {\n    var seneca = this\n\n    var preload = plugin.init.preload\n    preload = _.isFunction(preload) ? preload : _.noop\n    var meta = preload.call(seneca, plugin) || {}\n\n    var fullname = plugin.name + (plugin.tag ? '/' + plugin.tag : '')\n    plugin.fullname = fullname\n\n    var delegate = make_delegate(seneca, plugin)\n\n    seq++\n\n    var plugin_define_pattern = {\n      role: 'seneca',\n      plugin: 'define',\n      name: plugin.name,\n      seq: seq\n    }\n\n    if (plugin.tag !== null) {\n      plugin_define_pattern.tag = plugin.tag\n    }\n\n    // seneca\n    delegate\n      .add(plugin_define_pattern, plugin_definition)\n      .act({\n        role: 'seneca',\n        plugin: 'define',\n        name: plugin.name,\n        tag: plugin.tag,\n        seq: seq,\n        default$: {},\n        // gate$: true,\n        fatal$: true,\n        local$: true\n      })\n\n    // needed for seneca.export to operate for plugins like seneca-web\n    var preloadName = meta.name || plugin.name\n    var preloadRef = preloadName + (plugin.tag ? '/' + plugin.tag : '')\n    seneca.private$.exports[preloadName] = meta.export || plugin\n\n    resolve_plugin_exports(seneca, preloadRef, meta)\n\n    function plugin_definition (msg, plugin_done) {\n      var plugin_seneca = this\n      var plugin_options = resolve_options(fullname, plugin, seneca)\n\n      // Update plugin options data in Seneca options.\n      var seneca_options = {plugin: {}}\n      seneca_options.plugin[fullname] = plugin_options\n      seneca.options(seneca_options)\n\n      plugin_seneca.log.debug({\n        kind: 'plugin',\n        case: 'init',\n        name: plugin.name,\n        tag: plugin.tag,\n        options: plugin_options,\n        callpoint: callpoint\n      })\n\n      try {\n        meta = define_plugin(plugin_seneca, plugin, plugin_options)\n      }\n      catch (e) {\n        // TODO: needs wrapping\n        return plugin_done(e)\n      }\n\n      // legacy api for service function\n      if (_.isFunction(meta)) {\n        meta = {service: meta}\n      }\n\n      plugin.name = meta.name || plugin.name\n      plugin.tag =\n        meta.tag ||\n        plugin.tag ||\n        (plugin.options && plugin.options.tag$)\n\n      plugin.fullname = plugin.name + (plugin.tag ? '/' + plugin.tag : '')\n\n      plugin.service = meta.service || plugin.service\n\n      plugin_seneca.__update_plugin__(plugin)\n\n      var pluginref = plugin.name + (plugin.tag ? '/' + plugin.tag : '')\n      seneca.private$.plugins[pluginref] = plugin\n\n      seneca.private$.plugin_order.byname.push(plugin.name)\n      seneca.private$.plugin_order.byname = _.uniq(seneca.private$.plugin_order.byname)\n      seneca.private$.plugin_order.byref.push(pluginref)\n\n\n      var exports = resolve_plugin_exports(plugin_seneca, pluginref, meta)\n\n      plugin_seneca.log.debug({\n        kind: 'plugin',\n        case: 'install',\n        name: plugin.name,\n        tag: plugin.tag,\n        exports: exports\n      })\n\n      plugin_seneca.act(\n        {\n          init: plugin.name,\n          tag: plugin.tag,\n          default$: {},\n          fatal$: true,\n          local$: true\n        },\n        function (err, out) {\n          if (err) {\n            var plugin_err_code = 'plugin_init'\n\n            plugin.plugin_error = err.message\n\n            if (err.code === 'action-timeout') {\n              plugin_err_code = 'plugin_init_timeout'\n              plugin.timeout = so.timeout\n            }\n\n            return plugin_seneca.die(internals.error(err, plugin_err_code, plugin))\n          }\n\n          var fullname = plugin.name + (plugin.tag ? '$' + plugin.tag : '')\n\n          if (so.debug.print && so.debug.print.options) {\n            console.log('\\nSeneca Options (' + seneca.id + '): plugin: ' +\n                        fullname + '\\n' +\n                        '===\\n')\n            console.log(Util.inspect(plugin_options, { depth: null }))\n            console.log('')\n          }\n\n          plugin_seneca.log.debug({\n            kind: 'plugin',\n            case: 'ready',\n            name: plugin.name,\n            tag: plugin.tag\n          })\n\n          plugin_done()\n        }\n      )\n    }\n  }\n}\n\ninternals.isRegistered = function api_hasplugin (plugindesc, tag) {\n  var seneca = this\n  tag = (tag === '' || tag === '-') ? null : tag\n  return !!seneca.findplugin(plugindesc, tag)\n}\n\ninternals.find = function find (plugindesc, tag) {\n  var seneca = this\n  var name = plugindesc.name || plugindesc\n  tag = plugindesc.tag || tag\n\n  var key = name + (tag ? '/' + tag : '')\n  var plugin = seneca.private$.plugins[key]\n\n  return plugin\n}\n\ninternals.all = function all () {\n  return _.clone(this.private$.plugins)\n}\n\nmodule.exports.make_delegate = make_delegate\n\nfunction resolve_options (fullname, plugindef, seneca) {\n  var so = seneca.options()\n\n  var fullname_options = _.extend(\n    {},\n    so[fullname],\n    so.plugin[fullname],\n    so[fullname + '$' + plugindef.tag],\n    so.plugin[fullname + '$' + plugindef.tag]\n )\n\n  var shortname = fullname !== plugindef.name ? plugindef.name : null\n  if (!shortname && fullname.indexOf('seneca-') === 0) {\n    shortname = fullname.substring('seneca-'.length)\n  }\n\n  var shortname_options = _.extend(\n    {},\n    so[shortname],\n    so.plugin[shortname],\n    so[shortname + '$' + plugindef.tag],\n    so.plugin[shortname + '$' + plugindef.tag]\n )\n\n  var outopts = _.extend({},\n    shortname_options,\n    fullname_options,\n    plugindef.options || {})\n\n  return outopts\n}\n\nfunction make_delegate (instance, plugin) {\n  // Adjust Seneca API to be plugin specific.\n  var delegate = instance.delegate({\n    plugin$: {\n      name: plugin.name,\n      tag: plugin.tag\n    },\n\n    // Act calls inside the plugin definition function are not gated.\n    // ungate$: true,\n    fatal$: true\n  })\n\n  delegate.plugin_foo = true\n\n  delegate.private$ = Object.create(instance.private$)\n  delegate.private$.ge = delegate.private$.ge.gate()\n\n  delegate.log = instance.make_log(\n    delegate,\n    function plugin_delegate_log_modifier (data) {\n      data.plugin_name = plugin.name\n      data.plugin_tag = plugin.tag\n    })\n\n  delegate.die = Common.makedie(delegate, { type: 'plugin', plugin: plugin.name })\n\n  var actmetalist = []\n\n  delegate.add = function () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var actmeta = argsarr[argsarr.length - 1] || {}\n\n    if (_.isFunction(actmeta)) {\n      actmeta = {}\n      argsarr.push(actmeta)\n    }\n\n    actmeta.plugin_name = plugin.name || '-'\n    actmeta.plugin_tag = plugin.tag || '-'\n    actmeta.plugin_fullname = plugin.fullname\n\n    // TODO: is this necessary?\n    actmeta.log = delegate.log\n\n    actmetalist.push(actmeta)\n\n    instance.add.apply(delegate, argsarr)\n\n    return delegate\n  }\n\n  delegate.__update_plugin__ = function (plugin) {\n    delegate.context.name = plugin.name || '-'\n    delegate.context.tag = plugin.tag || '-'\n    delegate.context.full = plugin.fullname || '-'\n\n    _.each(actmetalist, function (actmeta) {\n      actmeta.plugin_name = plugin.name || actmeta.plugin_name || '-'\n      actmeta.plugin_tag = plugin.tag || actmeta.plugin_tag || '-'\n      actmeta.plugin_fullname =\n        plugin.fullname || actmeta.plugin_fullname || '-'\n    })\n  }\n\n  delegate.context.module = plugin.parent || module\n  delegate.context.name = plugin.name || '-'\n  delegate.context.tag = plugin.tag || '-'\n  delegate.context.full = plugin.fullname\n  delegate.context.isplugin = true\n\n  return delegate\n}\n\nfunction define_plugin (delegate, plugin, options) {\n  // legacy plugins\n  if (plugin.init.length > 1) {\n    plugin.init_func_sig = plugin.init.toString().match(/^(.*)\\n/)[1]\n    throw internals.error('unsupported_legacy_plugin', plugin)\n  }\n\n  var meta = plugin.init.call(delegate, options) || {}\n\n  meta = _.isString(meta) ? {name: meta} : meta\n  meta.options = meta.options || options\n\n  var updated_options = {}\n  updated_options[plugin.fullname] = meta.options\n  delegate.options(updated_options)\n\n  return meta\n}\n\n\nfunction resolve_plugin_exports (seneca, pluginref, meta) {\n  var exports = []\n\n  if (meta.export !== void 0) {\n    seneca.private$.exports[pluginref] = meta.export\n    exports.push(pluginref)\n  }\n\n  if (_.isObject(meta.exportmap) || _.isObject(meta.exports)) {\n    meta.exportmap = meta.exportmap || meta.exports\n    _.each(meta.exportmap, function (v, k) {\n      if (v !== void 0) {\n        var exportname = pluginref + '/' + k\n        seneca.private$.exports[exportname] = v\n        exports.push(exportname)\n      }\n    })\n  }\n\n  // Specific Seneca extension points\n  if (_.isObject(meta.extend)) {\n    if (_.isFunction(meta.extend.action_modifier)) {\n      seneca.private$.action_modifiers.push(meta.extend.action_modifier)\n    }\n\n    if (_.isFunction(meta.extend.logger)) {\n      if (!meta.extend.logger.replace &&\n          _.isFunction(seneca.private$.logger.add)) {\n        seneca.private$.logger.add(meta.extend.logger)\n      }\n      else {\n        seneca.private$.logger = meta.extend.logger\n      }\n    }\n  }\n\n  return exports\n}\n\n\nmodule.exports.api_decorations = {\n  hasplugin: internals.isRegistered,\n  findplugin: internals.find,\n  plugins: internals.all\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/print.js":"/* Copyright (c) 2015 Richard Rodger, MIT License */\n'use strict'\n\n\n// Node API modules\nvar Util = require('util')\n\n\n// External modules.\nvar _ = require('lodash')\nvar Archy = require('archy')\nvar Minimist = require('minimist')\n\n\n/** Handle command line specific functionality */\nmodule.exports = function (seneca) {\n  var argv = Minimist(process.argv.slice(2))\n  if (!argv || !argv.seneca) {\n    return\n  }\n  var cmdspec = argv.seneca\n  if (cmdspec.print) {\n    if (cmdspec.print.tree) {\n      // Hack! Complex init means non-deterministic or multiple ready calls,\n      // so just delay tree print by some number of seconds to capture full tree.\n      var delay_seconds = cmdspec.print.tree.all || cmdspec.print.tree\n      if (_.isNumber(delay_seconds)) {\n        setTimeout(function () {\n          print_tree(seneca, cmdspec)\n        }, 1000 * delay_seconds)\n      }\n      else {\n        // Print after first ready\n        seneca.ready(function () {\n          print_tree(this, cmdspec)\n        })\n      }\n    }\n\n    if (cmdspec.print.options) {\n      seneca.options({ debug: { print: { options: true } } })\n    }\n  }\n}\n\n\nmodule.exports.print_options = function print_options (options) {\n  if (options.debug.print.options) {\n    console.log('\\nSeneca Options (' + root.id + '): before plugins\\n' + '===\\n')\n    console.log(Util.inspect(options, { depth: null }))\n    console.log('')\n  }\n}\n\n\nfunction print_tree (seneca, cmdspec) {\n  var tree = {\n    label: 'Seneca action patterns for instance: ' + seneca.id,\n    nodes: []\n  }\n\n  function insert (nodes, current) {\n    if (nodes.length === 0) return\n\n    for (var i = 0; i < current.nodes.length; i++) {\n      if (nodes[0] === current.nodes[i].label) {\n        return insert(nodes.slice(1), current.nodes[i])\n      }\n    }\n\n    var nn = {label: nodes[0], nodes: []}\n    current.nodes.push(nn)\n    insert(nodes.slice(1), nn)\n  }\n\n  _.each(seneca.list(), function (pat) {\n    var nodes = []\n    var ignore = false\n    _.each(pat, function (v, k) {\n      if (!cmdspec.print.tree.all &&\n        (k === 'role' &&\n        (v === 'seneca' ||\n        v === 'basic' ||\n        v === 'util' ||\n        v === 'entity' ||\n        v === 'web' ||\n        v === 'transport' ||\n        v === 'options' ||\n        v === 'mem-store' ||\n        v === 'seneca'\n       )) ||\n        k === 'init'\n     ) {\n        ignore = true\n      }\n      else {\n        nodes.push(k + ':' + v)\n      }\n    })\n\n    if (!ignore) {\n      var meta = seneca.find(pat)\n\n      var metadesc = []\n      while (meta) {\n        metadesc.push('# ' + (meta.plugin_fullname || '-') +\n          ', ' + meta.id + ', ' + meta.func.name)\n        meta = meta.priormeta\n      }\n\n      nodes.push((metadesc.join('\\n')))\n\n      insert(nodes, tree)\n    }\n  })\n\n  console.log(Archy(tree))\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/transport.js":"/* Copyright (c) 2010-2016 Richard Rodger and other contributors, MIT License */\n'use strict'\n\nvar _ = require('lodash')\nvar Eraro = require('eraro')\nvar Jsonic = require('jsonic')\nvar Common = require('./common')\nvar Errors = require('./errors')\nvar Plugins = require('./plugins')\n\nvar internals = {\n  error: Eraro({\n    package: 'seneca',\n    msgmap: Errors,\n    override: true\n  })\n}\n\n\nexports.listen = function (callpoint) {\n  return function api_listen () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var self = this\n    var lastArg = _.last(argsarr)\n    if (typeof lastArg === 'function') {\n      argsarr.pop()\n    }\n\n    self.log.debug({\n      kind: 'listen',\n      options: argsarr,\n      callpoint: callpoint()\n    })\n\n    var opts = self.options().transport || {}\n    var config = internals.resolveConfig(internals.parse_config(argsarr), opts)\n\n    self.act(\n      'role:transport,cmd:listen',\n      { config: config, gate$: true },\n      function (err, result) {\n        if (err) {\n          return self.die(internals.error(err, 'transport_listen', config))\n        }\n\n        if (typeof lastArg === 'function') {\n          lastArg(null, result)\n          lastArg = _.noop\n        }\n      })\n\n    return self\n  }\n}\n\n\nexports.client = function (callpoint) {\n  return function api_client () {\n    var argsarr = new Array(arguments.length)\n    for (var l = 0; l < argsarr.length; ++l) { argsarr[l] = arguments[l] }\n\n    var self = this\n\n    self.log.debug({\n      kind: 'client',\n      options: argsarr,\n      callpoint: callpoint()\n    })\n\n    var opts = self.options(null).transport || {}\n\n    var raw_config = internals.parse_config(argsarr)\n\n    // pg: pin group\n    raw_config.pg = Common.pincanon(raw_config.pin || raw_config.pins)\n\n    var config = internals.resolveConfig(raw_config, opts)\n\n    config.id = config.id || Common.pattern(raw_config)\n\n    var pins = config.pins ||\n          (_.isArray(config.pin) ? config.pin : [config.pin || ''])\n\n    pins = _.map(pins, function (pin) {\n      return _.isString(pin) ? Jsonic(pin) : pin\n    })\n\n    var sd = Plugins.make_delegate(self, { name: 'client$', tag: void 0 })\n\n    var sendclient\n\n\n    var transport_client = function transport_client (msg, done) {\n      if (msg.local$) {\n        this.prior(msg, done)\n      }\n      else {\n        sendclient.send.call(this, msg, done)\n      }\n    }\n\n    transport_client.id = config.id\n\n    if (config.makehandle) {\n      transport_client.handle = config.makehandle(config)\n    }\n\n    _.each(pins, function (pin) {\n      pin = _.clone(pin)\n      pin.client$ = true\n      pin.internal$ = {catchall: true}\n\n      sd.add(pin, transport_client)\n    })\n\n\n    // Create client.\n    sd.act(\n      'role:transport,cmd:client',\n      { config: config, gate$: true },\n      function (err, liveclient) {\n        if (err) {\n          return sd.die(internals.error(err, 'transport_client', config))\n        }\n\n        if (liveclient === null) {\n          return sd.die(internals.error('transport_client_null',\n                                        Common.clean(config)))\n        }\n\n        sendclient = liveclient\n      })\n\n    return self\n  }\n}\n\n\ninternals.parse_config = function (args) {\n  var out = {}\n\n  var config = _.compact(args)\n\n  var arglen = config.length\n\n  if (arglen === 1) {\n    if (_.isObject(config[0])) {\n      out = _.clone(config[0])\n    }\n    else {\n      out.port = parseInt(config[0], 10)\n    }\n  }\n  else if (arglen === 2) {\n    out.port = parseInt(config[0], 10)\n    out.host = config[1]\n  }\n  else if (arglen === 3) {\n    out.port = parseInt(config[0], 10)\n    out.host = config[1]\n    out.path = config[2]\n  }\n\n  return out\n}\n\ninternals.resolveConfig = function (config, options) {\n  var out = _.clone(config)\n\n  _.each(options, function (value, key) {\n    if (_.isObject(value)) {\n      return\n    }\n    out[key] = (out[key] === void 0 ? value : out[key])\n  })\n\n  // Default transport is web\n  out.type = out.type || 'web'\n\n  // Aliases.\n  if (out.type === 'direct' || out.type === 'http') {\n    out.type = 'web'\n  }\n\n  var base = options[out.type] || {}\n\n  out = _.extend({}, base, out)\n\n  if (out.type === 'web' || out.type === 'tcp') {\n    out.port = out.port == null ? base.port : out.port\n    out.host = out.host == null ? base.host : out.host\n    out.path = out.path == null ? base.path : out.path\n  }\n\n  return out\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca/lib/logging.js":"/* Copyright (c) 2016 Richard Rodger and other contributors, MIT License */\n'use strict'\n\n\nvar Util = require('util')\n\n\nvar Stringify = require('json-stringify-safe')\nvar LogFilter = require('seneca-log-filter')\nvar _ = require('lodash')\n\nmodule.exports = logging\n\nfunction logging (options) {\n  // Everything is in preload as logging plugins are\n  // a special case that need to be loaded before any calls to seneca.log.\n}\n\nlogging.preload = function () {\n  var seneca = this\n  var so = seneca.options()\n  var logspec = so.log.basic || so.log || {}\n\n  var origspec = logspec\n\n  if (_.isString(logspec)) {\n    if ('quiet' === logspec) {\n      logspec = {level: 'none'}\n    }\n    else if ('silent' === logspec) {\n      logspec = {level: 'none'}\n    }\n    else if ('any' === logspec) {\n      logspec = {level: 'debug+'}\n    }\n    else if ('all' === logspec) {\n      logspec = {level: 'debug+'}\n    }\n    else if ('print' === logspec) {\n      logspec = {level: 'debug+'}\n    }\n    else if ('standard' === logspec) {\n      logspec = {level: 'info+'}\n    }\n    else if ('test' === logspec) {\n      logspec = {level: 'warn+'}\n    }\n  }\n\n  var logrouter = LogFilter(logspec)\n\n  var logger = function (seneca, data) {\n    if (logrouter(data)) {\n      console.log(Stringify(data))\n    }\n  }\n\n  // Test mode prints more readable logs\n  if (so.test) {\n    logger = function (seneca, data) {\n      if (logrouter(data)) {\n        try {\n          var logstr\n          var time = data.when - seneca.start_time\n\n          if ('test' === origspec || 'print' === origspec) {\n            var logb = [\n              time + '/' + seneca.id.substring(0, 2),\n              data.kind + (data.case ? '/' + data.case : '')]\n\n            if ('act' === data.kind) {\n              if (data.msg) {\n                logb.push(data.msg.meta$.id.split('/').map(function (s) {\n                  return s.substring(0, 2)\n                }).join('/'))\n\n                logb.push(data.msg.meta$.pattern)\n              }\n\n              logb.push(Util.inspect(seneca.util.clean(data.result || data.msg))\n                        .replace(/\\s+/g, '')\n                        .substring(0, 88))\n\n              if (data.notice) {\n                logb.push(data.notice)\n              }\n\n              if ('ERR' === data.case) {\n                logb.push('\\n\\n' + data.err.stack + '\\n' + data.caller + '\\n')\n              }\n            }\n            else if ('add' === data.kind) {\n              logb.push(data.pattern)\n            }\n            else if ('plugin' === data.kind) {\n              logb.push(data.plugin_name +\n                        (data.plugin_tag ? '/' + data.plugin_tag : ''))\n            }\n            else if ('options' === data.kind) {\n            }\n            else if ('notice' === data.kind) {\n              logb.push(data.notice)\n            }\n            else {\n              logb.push(Util.inspect(data).replace(/\\n/g, ' '))\n            }\n\n            logstr = logb.join('\\t')\n          }\n          else {\n            logstr = Util.inspect(data, {depth: null})\n            logstr =\n              time + ':\\n\\t' +\n              logstr.replace(/\\n/g, '\\n\\t') +\n              '\\n------------------------------------------------\\n\\n'\n          }\n\n          console.log(logstr)\n        }\n        catch (e) {\n          console.log(data)\n        }\n      }\n    }\n  }\n\n  return {\n    extend: {\n      logger: logger\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca-log-filter/seneca-log-filter.js":"'use strict'\n\nconst Util = require('./lib/util')\nconst Aliases = require('./lib/aliases')\nconst _ = require('lodash')\n\nfunction logfilter (options) {\n  let level = options.level || 'info+'\n\n  let calculatedLevels = []\n\n  if (Util.level_exists(level)) {\n    calculatedLevels.push(level)\n  }\n  // Level + notation\n  else if (_.endsWith(level, '+')) {\n    calculatedLevels = Util.log_level_plus(level.substring(0, level.length - 1))\n  }\n  // No level nor level+... it must be a custom alias\n  else {\n    let processedAliases = Object.assign(Aliases, options.aliases)\n    let aliasInfo = processedAliases[level]\n    if (aliasInfo) {\n      let handled = _.get(aliasInfo, 'handled', true)\n      if (handled) {\n        calculatedLevels = aliasInfo.handler(options)\n      }\n    }\n  }\n\n  return function filter (data) {\n    if (calculatedLevels.indexOf(data.level) !== -1) {\n      let cloned = _.clone(data)\n      if (options['omit-metadata']) {\n        cloned = _.omit(cloned, ['seneca', 'level', 'when'])\n      }\n      if (options.omit && _.isArray(options.omit)) {\n        cloned = _.omit(cloned, options.omit)\n      }\n      return cloned\n    }\n    return null\n  }\n}\n\nmodule.exports = logfilter\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca-log-filter/lib/util.js":"'use strict'\n\nconst log_levels = ['debug', 'info', 'warn', 'error', 'fatal']\n\n/**\n * It returns the levels above the argument\n * @param  {String} logLevel the log level to calculate\n * @return {Array}           the list of logs above the argument\n */\nfunction log_level_plus (logLevel) {\n  let index = log_levels.indexOf(logLevel)\n  if (index < 0) {\n    return []\n  }\n  else {\n    return log_levels.slice(index, log_levels.length)\n  }\n}\n\n/**\n * Checks if a log level exists\n * @param  {string} level the level itself\n * @return {boolean}      true if the level exists\n */\nfunction level_exists (level) {\n  return log_levels.indexOf(level) !== -1\n}\n\nmodule.exports.log_level_plus = log_level_plus\nmodule.exports.level_exists = level_exists\n","/home/travis/build/npmtest/node-npmtest-seneca/node_modules/seneca-log-filter/lib/aliases.js":"/**\n * Default aliases for seneca.\n */\nmodule.exports = {\n  'silent': {\n    handled: true,\n    handler: function () { return [] }\n  },\n  'all': {\n    handled: true,\n    handler: function () { return ['debug', 'info', 'warn', 'error', 'fatal'] }\n  },\n  'test': {\n    handled: true,\n    handler: function () { return ['error', 'fatal'] }\n  }\n}\n"}